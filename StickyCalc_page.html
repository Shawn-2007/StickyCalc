<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0 ,maximum-scale=1.0, user-scalable=no">
    <title>StickyCalc 便利貼計算板</title>
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/my.css">
    <style>
        .leftMenu a {
            text-decoration: none;
            text-align: center;
        }

        .note-text-container,
        .chart-container,
        .row {
            width: 100%;
            height: 100%;
            position: relative;
        }


        .mind-map-container {
            width: 100vw;
            height: 100vh;

            overflow: hidden;
            position: relative;
            background: #f9f9f9;
            user-select: none;
        }

        .mind-map-container-dark {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            position: relative;
            background: #242424;
            user-select: none;
        }

        svg {
            width: 100%;
            height: 100%;
            /* cursor 預設 auto，可由各狀態動態變更 */
            cursor: auto;
        }

        .context-menu {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            padding: 5px;
            z-index: 1000;
            position: absolute;
        }

        .context-menu button {
            display: block;
            width: 100%;
            border: none;
            background: none;
            padding: 5px;
            text-align: left;
        }

        .context-menu button:hover {
            background: #eee;
        }

        .context-menu001 button:hover {
            background: #e7c795;
        }


        .edit-input {
            width: 100%;
            font-size: 12px;
            border: none;
            outline: none;
            background: transparent;
        }


        /* 通用工具列樣式 */
        .toolbar {
            position: fixed;
            height: 40px;
            background-color: #f0f0f0;
            /* 淺灰色背景，可自行調整 */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            /* 陰影效果 */
        }

        /* 左上工具列 */
        .toolbar-left {
            top: 0;
            left: 0;
            width: 300px;
            border-bottom-right-radius: 10px;
            /* 右下角為圓角 */
        }

        /* 右上工具列 */
        .toolbar-right {
            top: 0;
            right: 0;
            width: 200px;
            border-bottom-left-radius: 10px;
            /* 左下角為圓角 */
        }

        .title-container {
            max-width: 100px;
            /* 限制最大寬度 */
            overflow: hidden;
            /* 超出範圍的內容隱藏 */
            text-overflow: ellipsis;
            /* 顯示省略號 */
            white-space: nowrap;
            /* 不換行 */
        }

        /* 新增圖表相關樣式 */
        .chart-container {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .note-text-container {
            width: 100%;
            height: 90%;
            overflow: hidden;
            white-space: pre-wrap;
            /* 支援換行 */
            font-size: 14px;
            line-height: 1.2;
            position: relative;
        }

        .note-text {
            display: inline;
            overflow: hidden;
        }


        /* 垂直工具列 */
        .toolbar-vertical {
            position: fixed;
            /* 固定在畫面上 */
            left: 0;
            /* 靠左側邊緣 */
            top: 50%;
            /* 垂直置中 */
            transform: translateY(-50%);
            /* 偏移自身高度的一半以精準置中 */
            /* background-color: #070606; */
            background-color: #f0f0f0;
            /* 背景色，與你的設計一致 */
            border-right: 1px solid #ccc;
            /* 右側邊框 */
            display: flex;
            /* 使用 Flexbox 排列按鈕 */
            flex-direction: column;
            /* 垂直排列 */
            align-items: center;
            /* 按鈕水平置中 */
            padding: 2px 0;
            /* 上下內距 */
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
            /* 陰影效果 */
            z-index: 1000;
            /* 確保在畫板上方 */
            border-radius: 0 5px 5px 0;
            /* 圓角 */

        }

        /* 工具列按鈕 */
        .toolbar-button {
            width: 70px;
            /* 固定寬度 */
            height: 30px;
            /* 固定高度 */
            background: none;
            /* 無背景 */
            border: none;
            /* 無邊框 */
            cursor: pointer;
            /* 滑鼠指針 */
            margin: 5px 0;
            /* 上下間距 */
            margin-inline: -10px;
            /* 左右間距 */
            display: flex;
            /* Flexbox 置中內容 */
            align-items: center;
            /* 垂直置中 */
            justify-content: center;
            /* 水平置中 */
            border-radius: 5px;
            /* 圓角 */
            transition: background-color 0.2s;
            /* 背景色過渡效果 */
        }

        .toolbar-button:hover {
            background-color: #e0e0e0;
            /* 滑鼠懸停時變色 */
        }

        /* 暗黑模式按鈕 */
        :root {
            --width-of-switch: 3.5em;
            --height-of-switch: 2em;
            --size-of-icon: 1.4em;
            --slider-offset: 0.3em;
        }

        .switch input {
            width: 0;
            height: 0;
            opacity: 0;
        }

        .switch {
            display: block;
            position: relative;
            width: var(--width-of-switch);
            height: var(--height-of-switch);
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #d1e2eb;
            transition: 0.4s;
            border-radius: 30px;
        }

        .slider::before {
            position: absolute;
            content: "";
            height: var(--size-of-icon);
            width: var(--size-of-icon);
            border-radius: 20px;
            left: var(--slider-offset);
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(40deg, #ff0080, #ff8c00 70%);
            transition: 0.4s;
        }

        input:checked+.slider {
            background: #303136;
        }

        input:checked+.slider::before {
            /* left: calc(100% - (var(--size-of-icon)+var(--slider-offset))); */
            left: 50%;
            background: #303136;
            /* box-shadow: inset -3px -2px 5px 2px #8982f7; */
            box-shadow: inset -3px -2px 5px 2px #8982f7, inset -10px -4px 0 0 #a3dafb;
        }

        /* IPHONE直立式 orientation方向: portrait縱向*/
        @media (max-width: 768px) and (orientation: portrait) {

            /* 右上工具列 */
            .toolbar-right {
                width: 120px;
            }

            /* 左上工具列 */
            .toolbar-left {
                width: 230px;
            }

        }
    </style>
</head>

<body>
    <div id="app">
        <!-- 外層容器，點擊時隱藏右鍵選單 -->
        <div :class="['mind-map-container', { 'mind-map-container-dark': isDark }]" @click="hideContextMenu">
            <!-- 左上工具列 -->
            <div class="toolbar toolbar-left">
                <div class="mt-2 d-flex">
                    <div class="ms-2 me-2">
                        <a href="#" @click="pageNodesUpload" class="nav-link">
                            <!-- 前往上一頁 -->
                            <svg-icon name="svg-previousPage"></svg-icon>
                        </a>
                    </div>
                    <!-- 雙擊執行 -->
                    <label v-if="!editName" for="" class="form-check-label" @dblclick="edittodo()">{{boardName}}</label>
                    <div v-if="editName" class="">
                        <input type="text" class="form-control" v-model="boardName" name="" id=""
                            @keyup.enter="edittodo()" @keyup.esc="edittodo()" placeholder="編輯檔名">
                    </div>

                    <div class="">
                        <svg xmlns="http://www.w3.org/2000/svg" width="2" height="27" fill="none">
                            <path
                                d="M0 0.999999C0 0.447715 0.447715 0 1 0C1.55228 0 2 0.447715 2 1V26C2 26.5523 1.55228 27 1 27C0.447715 27 0 26.5523 0 26V0.999999Z"
                                fill="#D9D9D9" />
                        </svg>
                    </div>
                    <!-- 存檔 -->
                    <div class="ms-1">
                        <a href="#" @click="nodesUpload" class="nav-link">
                            <svg-icon :name="isAutoUpload ? 'svg-upload-ok' : 'svg-upload'"></svg-icon>
                        </a>
                    </div>
                    <!-- 讀檔 -->
                    <div class="ms-2">
                        <!-- <a href="#" @click="get_nodes" class="nav-link">
                            <svg-icon name="svg-loader"></svg-icon>
                        </a> -->
                    </div>
                    <!-- 上一步 -->
                    <div class="ms-auto me-2" @click="undo">
                        <svg-icon name="svg-toReturn"></svg-icon>
                    </div>
                    <!-- 下一步 -->
                    <div class="me-2">
                        <svg-icon name="svg-unReturn"></svg-icon>

                    </div>
                </div>
            </div>

            <!-- 右上工具列 -->
            <div class="toolbar toolbar-right">
                <div class="d-flex">
                    <div v-if="!isMobile" class="ms-3" data-title="LOGO">
                        <a href="#" @click="goIndex">
                            <!-- LOGO -->
                            <svg-icon name="svg-logo"></svg-icon>
                        </a>
                    </div>
                    <!-- <div class="mx-3" data-title="下載" style="margin-top: -10px;">
                        <svg-icon name="svg-download"></svg-icon>
                    </div> -->
                    <div class="darkLightSwitch mt-1 ms-auto">
                        <label class="switch">
                            <input type="checkbox" v-model="isDark">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="mx-1 " data-title="更多">
                        <div class="dropdown">
                            <button class="btn btn-link" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <svg-icon name="svg-more"></svg-icon>
                            </button>
                            <ul class="dropdown-menu">
                                <li><a class="dropdown-item" href="#" @click="shareBoard()">共用</a></li>
                                <li><a class="dropdown-item" href="#" @click="sendBoard()">分享</a></li>
                                <li><a class="dropdown-item" href="#" @click="deleteBoard()">刪除</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 垂直工具列（新增） 全上462px 一般82px 貼246px 線348px -->
            <div class="toolbar toolbar-vertical" :style="{height: computedToolbarHeight + 'px' }">
                <!-- 新增便利貼 -->
                <button class="toolbar-button" @click="addNodeAtRight">
                    <svg-icon name="svg-addNode"></svg-icon>
                </button>
                <!-- 新增圖表便利貼 -->
                <button class="toolbar-button" @click="addChartNodeRight">
                    <svg-icon name="svg-addChartNode"></svg-icon>
                </button>
                <!-- 刪除便利貼 -->
                <button v-if="selectedNode || selectedConn || selectedChert" class="toolbar-button"
                    @click="deleteBtn()">
                    <svg-icon name="svg-deleteNode"></svg-icon>
                </button>
                <!-- general換色粉紅 -->
                <button v-if="selectedNode" class="toolbar-button" style="margin: 1px;"
                    @click="changeNodeColor('general', '#ffc0cb', '#FCAFAA')">
                    <svg-icon name="svg-nodeColorPink"></svg-icon>
                </button>
                <!-- general換色粉綠 -->
                <button v-if="selectedNode" class="toolbar-button" style="margin: 1px;"
                    @click="changeNodeColor('general', '#D3ED7F', '#C7DF7A')">
                    <svg-icon name="svg-nodeColorGreen"></svg-icon>
                </button>
                <!-- general換色粉藍 -->
                <button v-if="selectedNode" class="toolbar-button" style="margin: 1px;"
                    @click="changeNodeColor('general', '#CEEBFD', '#ADD8E6')">
                    <svg-icon name="svg-nodeColorBlue"></svg-icon>
                </button>
                <!-- general換色粉黃 -->
                <button v-if="selectedNode" class="toolbar-button" style="margin: 1px;"
                    @click="changeNodeColor('general', '#FFF8CA', '#FFF4B2')">
                    <svg-icon name="svg-nodeColorYellow"></svg-icon>
                </button>
                <!-- svgIcon:線條類型:實線 -->
                <button v-if="selectedConn" class="toolbar-button" @click="changeLineType('solid')">
                    <svg-icon name="svg-lineTypeEntity"></svg-icon>
                </button>
                <!-- svgIcon:線條類型:中空線 -->
                <button v-if="selectedConn" class="toolbar-button" @click="changeLineType('dashed')">
                    <svg-icon name="svg-lineTypeHollow"></svg-icon>
                </button>
                <!-- svgIcon:線條類型:虛線 -->
                <button v-if="selectedConn" class="toolbar-button" @click="changeLineType('dotted')">
                    <svg-icon name="svg-lineTypeDottedLine"></svg-icon>
                </button>
                <!-- 線條顏色 粉紅 -->
                <button v-if="selectedConn" class="toolbar-button" style="margin: 0px;"
                    @click="changeLineColor('#FCAFAA')">
                    <svg-icon name="svg-lineColorPink"></svg-icon>
                </button>
                <!-- 線條顏色 粉綠 -->
                <button v-if="selectedConn" class="toolbar-button" style="margin: 0px;"
                    @click="changeLineColor('#C7DF7A')">
                    <svg-icon name="svg-lineColorGreen"></svg-icon>
                </button>
                <!-- 線條顏色 粉藍 -->
                <button v-if="selectedConn" class="toolbar-button" style="margin: 0px;"
                    @click="changeLineColor('#ADD8E6')">
                    <svg-icon name="svg-lineColorBlue"></svg-icon>
                </button>
                <!-- 線條顏色 橘黃 -->
                <button v-if="selectedConn" class="toolbar-button" style="margin: 0px;"
                    @click="changeLineColor('#FFB53E')">
                    <svg-icon name="svg-lineColorYellow"></svg-icon>
                </button>
            </div>

            <!-- 主要畫板SVG -->
            <svg id="mindmapSvg" :width="width" :height="height" @pointerdown="handleSvgPointerDown" :style="svgStyle"
                @pointermove="dragMove" @wheel.prevent="handleWheel" @pointerup="endDrag" @pointerleave="endDrag"
                @contextmenu.prevent="handleSvgContextMenu($event)">
                <!-- 定義 SVG 內部資源：格紋背景與箭頭 marker -->
                <defs>
                    <!-- 格紋背景，每格 20x20 -->
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 L 0 20" fill="none" :stroke="isDark?'#5a5a5a':'#ddd'" stroke-width="0.5">
                        </path>
                    </pattern>
                </defs>
                <!-- 使用格紋背景覆蓋整個 SVG -->
                <rect width="100%" height="100%" fill="url(#grid)" @dblclick="addNodeAtContext"
                    @pointerdown="handleBackgroundPointerDown"></rect>
                <!-- 將畫板內容包在 <g> 中，可統一進行平移與縮放 -->
                <g :transform="boardTransform">
                    <!-- 臨時連線 -->
                    <path v-if="tempConnection.active" :d="tempConnection.path" stroke="grey" fill="none"
                        stroke-width="3" stroke-dasharray="5,5"></path>

                    <!-- 連線 -->
                    <g v-for="(conn, index) in connections" :key="'conn-' + index">
                        <path :d="getConnectionPath(conn)" :stroke="conn.selected ? 'blue' : conn.color" fill="none"
                            :stroke-dasharray="conn.type" stroke-width="3" pointer-events="visibleStroke"
                            @click.stop="toggleConnectionSelection(conn, $event)"></path>
                        <!-- 終端圓圈 -->
                        <g v-if="getAdjustedArrowPosition(conn).x !== 0 && getAdjustedArrowPosition(conn).y !== 0">
                            <circle :cx="getAdjustedArrowPosition(conn).x" :cy="getAdjustedArrowPosition(conn).y" r="8"
                                fill="white" stroke="black" style="cursor: ns-resize;"
                                @pointerdown.stop="startDragArrow(conn, $event)">
                            </circle>
                            <text v-if="isDoubleConnection(conn)" :x="getAdjustedArrowPosition(conn).x"
                                :y="getAdjustedArrowPosition(conn).y + 3" text-anchor="middle" font-size="10"
                                fill="black">
                                {{ getConnectionLabel(conn) }}
                            </text>
                        </g>
                    </g>
                    <!-- 可拖動的便利貼 -->
                    <g v-for="(node, index) in nodes" :key="node.id" :data-id="node.id"
                        @pointerdown.stop="startDrag(node, $event)" @click.stop="nodeClick(node, $event)"
                        @mouseenter="hoveredNode = node" @mouseleave="hoveredNode = null" style="cursor: move;">
                        <!-- 便利貼背景 -->
                        <g>
                            <rect :x="node.x - noteWidth/2" :y="node.y - noteHeight/2" :width="noteWidth"
                                :height="noteHeight" :fill="node.color" stroke="#ccc" stroke-width="0" rx="1" ry="5"
                                style="filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));" @dblclick="editNode(node)">
                            </rect>
                            <rect :x="node.x - noteWidth/2" :y="node.y - noteHeight/2" :width="noteWidth" :height="26"
                                :fill="node.colorTop" rx="0" ry="0">
                            </rect>
                        </g>

                        <!-- 頂欄 -->
                        <template v-if="node.connectionsIn.length == 2">
                            <foreignObject :x="node.x - 50" :y="node.y - noteHeight / 2 - 4" width="100" height="32">
                                <select v-model="node.operation" @change="updateTotal(node)"
                                    style="width: 100%; height: 100%; font-size: 12px; border: none; outline: none; background: transparent; text-align: center;">
                                    <option value="sum">+ 加法</option>
                                    <option value="subtractAB">- 減法</option>
                                    <option value="multiply">× 乘法</option>
                                    <option value="divideAB">÷ 除法</option>
                                    <option value="modulusAB">% 餘數</option>
                                </select>
                            </foreignObject>
                        </template>

                        <template v-else>
                            <text :x="node.x + noteWidth / 2 - 5" :y="node.y - noteHeight / 2 + 20" text-anchor="end"
                                font-size="18" fill="grey" font-weight="bold">
                                {{ node.total }}
                            </text>
                        </template>
                        <!-- 頂欄 -->


                        <!-- 編輯模式 -->
                        <template v-if="node.editing && node.type !== 'chart'">
                            <foreignObject :x="node.x - noteWidth/2 + 5" :y="node.y - noteHeight/2 + 30"
                                :width="noteWidth - 10" :height="noteHeight - 10" style="overflow: hidden;">
                                <textarea class="form-control bg-white bg-opacity-25" v-model="node.label"
                                    @blur="finishEdit(node)" @keyup.enter="finishEdit(node)"
                                    style="height: 86px;"></textarea>
                            </foreignObject>
                        </template>

                        <!-- 顯示模式 -->
                        <template v-else-if="node.type !== 'chart'">
                            <foreignObject :x="node.x - noteWidth/2 + 5" :y="node.y - noteHeight/2 + 30"
                                :width="noteWidth - 10" :height="noteHeight - 30">
                                <div class="note-text-container" :style="foreignObjectTransformStyle"
                                    @dblclick="draggingNodes.length ? null : editNode(node)">
                                    <!-- 一連以下顯示此段，label無內容顯示雙擊編輯 -->
                                    <span v-if="node.connectionsIn.length < 2" class="note-text">{{ node.label || "雙擊編輯"
                                        }}</span>
                                    <!-- 二連以上顯示此段，顯示總值或0 -->
                                    <span v-else class="note-text">{{ node.label }}</span>
                                </div>
                            </foreignObject>
                            <!-- 右下角「...」按鈕 -->
                            <svg v-if="node.connectionsIn.length < 2 && !node.editing" @click.stop="showFullText(node)"
                                :x="node.x + noteWidth/2 - 34" :y="node.y + noteHeight/2 - 20"
                                xmlns="http://www.w3.org/2000/svg" width="30" height="18" viewBox="0 0 30 18"
                                fill="none">
                                <rect width="30" height="18" rx="5" fill="#D9D9D9" fill-opacity="0" />
                                <path fill-rule="evenodd" clip-rule="evenodd"
                                    d="M2 9C2 7.89543 2.89543 7 4 7H6C7.10457 7 8 7.89543 8 9V10C8 11.1046 7.10457 12 6 12H4C2.89543 12 2 11.1046 2 10V9ZM12 9C12 7.89543 12.8954 7 14 7H16C17.1046 7 18 7.89543 18 9V10C18 11.1046 17.1046 12 16 12H14C12.8954 12 12 11.1046 12 10V9ZM24 7C22.8954 7 22 7.89543 22 9V10C22 11.1046 22.8954 12 24 12H26C27.1046 12 28 11.1046 28 10V9C28 7.89543 27.1046 7 26 7H24Z"
                                    fill="grey" />
                            </svg>

                            <!-- 選取邊框 -->
                            <rect v-if="node.selected && node.type != 'chart'" :x="node.x - noteWidth/2"
                                :y="node.y - noteHeight/2" :width="noteWidth" :height="noteHeight" fill="none"
                                stroke="blue" stroke-width="2" rx="1" ry="5" />

                            <!-- 連線圓圈 -->
                            <circle v-if="hoveredNode === node || node.selected" :cx="node.x - noteWidth/2 + 130"
                                :cy="node.y - noteHeight/2 + 62" r="12" fill="white" stroke="black"
                                style="cursor: pointer;" @pointerdown.stop="startDragConnectionCircle(node, $event)">
                            </circle>
                        </template>

                        <!-- 圖表便利貼 -->
                        <template v-else-if="node.type === 'chart'">
                            <g>
                                <!-- 底層矩形（淺色） -->
                                <rect :x="node.x - node.chartWidth/2" :y="node.y - node.chartHeight/2"
                                    :width="node.chartWidth" :height="node.chartHeight" :fill="node.color" stroke="#ccc"
                                    stroke-width="0" rx="1" ry="5"
                                    style="filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.3));"></rect>
                                <!-- 頂部矩形（深色） -->
                                <rect :x="node.x - node.chartWidth/2" :y="node.y - node.chartHeight/2"
                                    :width="node.chartWidth" :height="26" :fill="node.colorTop" rx="0" ry="0"></rect>
                            </g>
                            <!-- 圖表類型選擇（置於深色區） -->
                            <foreignObject :x="node.x - node.chartWidth/2 + 10" :y="node.y - node.chartHeight/2 + 2"
                                :width="node.chartWidth - 20" height="22">
                                <div class="row" :style="foreignObjectTransformStyle">
                                    <div class="col-6">
                                        <div class="">
                                            <!-- 按鈕 粉紅 -->
                                            <button type="button" class="btn btn-sm "
                                                @click="changeNodeColor('chart', '#FFE6EB', '#FCAFAA')"
                                                style="height: 30px; width: 30px; margin-top: -50">
                                                <svg-main name="svg-chartColorPink"></svg-main>

                                            </button>
                                            <!-- 按鈕 粉綠 -->
                                            <button type="button" class="btn btn-sm "
                                                @click="changeNodeColor('chart', '#F7FFDB', '#C7DF7A')"
                                                style="height: 30px; width: 30px; margin-top: -50">
                                                <svg-main name="svg-chartColorGreen"></svg-main>
                                            </button>
                                            <!-- 按鈕 粉藍 -->
                                            <button type="button" class="btn btn-sm"
                                                @click="changeNodeColor('chart', '#E5F5FF', '#ADD8E6')"
                                                style="height: 30px; width: 30px; margin-top: -50">
                                                <svg-main name="svg-chartColorBlue"></svg-main>
                                            </button>
                                            <!-- 按鈕 白 -->
                                            <button type="button" class="btn btn-sm "
                                                @click="changeNodeColor('chart', '#fdfdfd', '#dddddd')"
                                                style="height: 30px; width: 30px; margin-top: -50;">
                                                <!-- transform="scale(1.8)" svg縮放大小 -->
                                                <svg-main name="svg-chartColorWhite"></svg-main>

                                            </button>
                                        </div>
                                    </div>

                                    <div class="col-6" style="margin-top: -10px;">
                                        <select v-model="node.chartType" @change="renderChart(node)"
                                            style="width: 100%; height: 100%; font-size: 12px; border: none; outline: none; background: transparent; text-align: center;">
                                            <option value="bar">柱狀圖</option>
                                            <option value="line">折線圖</option>
                                            <option value="area">面積圖</option>
                                            <option value="radar">雷達圖</option>
                                            <option value="pie">圓餅圖</option>
                                            <option value="polarArea">極座標圓餅圖</option>
                                            <option value="donut">甜甜圈</option>
                                            <option value="radialBar">跑道圖</option>
                                            <!-- <option value="rangeBar">時間圖</option> -->
                                        </select>
                                    </div>
                                </div>
                            </foreignObject>
                            <!-- 圖表容器 -->
                            <foreignObject :x="node.x - node.chartWidth/2 + 10" :y="node.y - node.chartHeight/2 + 30"
                                :width="node.chartWidth - 20" :height="node.chartHeight - 40">
                                <div :id="node.id" class="chart-container" :style="foreignObjectTransformStyle"></div>
                            </foreignObject>
                            <rect :x="node.x + node.chartWidth/2 - 15" :y="node.y + node.chartHeight/2 - 15" width="15"
                                height="15" fill="grey" stroke="black" stroke-width="1" style="cursor: se-resize;"
                                @pointerdown.stop="startResize(node, $event)" />
                            <!-- 選取邊框 -->
                            <rect v-if="node.selected" :x="node.x - node.chartWidth/2" :y="node.y - node.chartHeight/2"
                                :width="node.chartWidth" :height="node.chartHeight" fill="none" stroke="blue"
                                stroke-width="2" rx="5" ry="5" />
                        </template>
                    </g>

                    <!-- 畫板邊緣浮動箭頭（若有便條紙超出可見範圍則顯示） -->
                    <g>
                        <text v-if="showLeftArrow" class="floating-arrow" x="10" :y="height/2" fill="blue"
                            @click="scrollTo('left')">&#9664;</text>
                        <text v-if="showRightArrow" class="floating-arrow" :x="width - 20" :y="height/2" fill="blue"
                            @click="scrollTo('right')">&#9654;</text>
                        <text v-if="showTopArrow" class="floating-arrow" :x="width/2" y="20" fill="blue"
                            @click="scrollTo('top')">&#9650;</text>
                        <text v-if="showBottomArrow" class="floating-arrow" :x="width/2" :y="height - 10" fill="blue"
                            @click="scrollTo('bottom')">&#9660;</text>
                    </g>
                    <!-- 框選的選取框 -->
                    <rect v-if="selectionBox.active" :x="selectionBox.x" :y="selectionBox.y" :width="selectionBox.width"
                        :height="selectionBox.height" stroke="#4D74F4" stroke-dasharray="4,4" fill="none" />
                </g>
            </svg>

            <!-- 考慮留存 -->
            <!-- 右鍵選單 -->
            <div v-if="contextMenu.visible" class="context-menu"
                :style="{ left: contextMenu.x + 'px', top: contextMenu.y + 'px' }">
                <template v-if="contextMenu.type === 'blank'">
                    <button type="button" class="btn btn-sm " @click="addNodeAtContext"
                        style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                        <svg-icon name="svg-addNode"></svg-icon>
                    </button>
                    <button type="button" class="btn btn-sm " @click="addChartNodeAtContext"
                        style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                        <svg-icon name="svg-addChartNode"></svg-icon>
                    </button>
                    <button type="button" class="btn btn-sm " @click="deleteBtn"
                        style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                        <svg-icon name="svg-deleteNode"></svg-icon>
                    </button>
                    <div v-if="selectedNode">
                        <button @click="startConnection(contextMenu.node)">開始連線</button>
                        <div class="">
                            <!-- 按鈕 粉紅 -->
                            <button type="button" class="btn btn-sm "
                                @click="changeNodeColor('general', '#ffc0cb', '#FCAFAA')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lfetMenuPink"></svg-icon>
                            </button>
                            <!-- 按鈕 粉綠 -->
                            <button type="button" class="btn btn-sm "
                                @click="changeNodeColor('general', '#F7FFDB', '#C7DF7A')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lfetMenuGreen"></svg-icon>
                            </button>
                            <!-- 按鈕 粉藍 -->
                            <button type="button" class="btn btn-sm"
                                @click="changeNodeColor('general', '#CEEBFD', '#ADD8E6')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lfetMenuBlue"></svg-icon>
                            </button>
                            <!-- 按鈕 粉黃 -->
                            <button type="button" class="btn btn-sm "
                                @click="changeNodeColor('general', '#FFF8CA', '#FFF4B2')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <!-- transform="scale(1.8)" svg縮放大小 -->
                                <svg-icon name="svg-lfetMenuYellow"></svg-icon>
                            </button>
                        </div>
                    </div>
                    <div class="" v-if="selectedConn">
                        <button @click="deleteConnection()">刪除此連線</button>
                        <div class="">
                            更換類型：
                        </div>
                        <div class="">
                            <!-- 線條類型 實線 -->
                            <button type="button" class="btn btn-sm " @click="changeLineType('solid')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineTypeEntity"></svg-icon>
                            </button>
                            <!-- 線條類型 中空線 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineType('dashed')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineTypeHollow"></svg-icon>
                            </button>
                            <!-- 線條類型 虛線 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineType('dotted')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineTypeDottedLine"></svg-icon>
                            </button>
                        </div>

                        <div>
                            <div v-if="selectedConn" class="">
                                更換顏色：
                            </div>
                            <!-- 線條顏色 粉紅 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineColor('#FCAFAA')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineColorPink"></svg-icon>
                            </button>
                            <!-- 線條顏色 粉綠 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineColor('#C7DF7A')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineColorGreen"></svg-icon>
                            </button>
                            <!-- 線條顏色 粉藍 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineColor('#ADD8E6')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block; ">
                                <svg-icon name="svg-lineColorBlue"></svg-icon>
                            </button>
                            <!-- 線條顏色 橘黃 -->
                            <button v-if="selectedConn" type="button" class="btn btn-sm "
                                @click="changeLineColor('#FFB53E')"
                                style="height: 30px; width: 30px; margin-top: -50;display: inline-block;  ">
                                <svg-icon name="svg-lineColorYellow"></svg-icon>
                            </button>
                        </div>
                    </div>
                </template>
            </div>
        </div>
    </div>
    <!-- --------------程 式 區 載 入 區-------------- -->
    <script src="js/bootstrap.bundle.min.js"></script>
    <script src="js/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- 引入 Moment.js -->
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>

    <!-- 引入 ApexCharts -->
    <script src="https://unpkg.com/apexcharts@latest/dist/apexcharts.min.js"></script>

    <script src="js/vue.global.js"></script>
    <script>
        // UI SVG
        const SvgIcon = {
            props: ['name'], // 動態傳入 SVG 名稱
            template: `
            <svg  v-if="name === 'svg-upload'"  xmlns="http://www.w3.org/2000/svg" width="35" height="28" viewBox="0 0 35 28"
                                transform="scale(0.8)" fill="none">
                                <path fill-rule="evenodd" clip-rule="evenodd"
                                    d="M15.5762 8.00193C16.0275 5.18599 18.5438 2.98696 21.6283 2.98696C25.0434 2.98696 27.7534 5.67576 27.7534 8.92151C27.7534 10.142 27.3744 11.275 26.721 12.2198L25.1418 14.5031L27.9079 14.2665C28.0152 14.2573 28.1243 14.2526 28.2352 14.2526C30.2817 14.2526 31.8827 15.8606 31.8827 17.773C31.8827 19.6855 30.2817 21.2935 28.2352 21.2935V23.9088C31.6615 23.9088 34.4979 21.1936 34.4979 17.773C34.4979 14.9068 32.5063 12.5358 29.8448 11.8427C30.1835 10.9313 30.3686 9.94727 30.3686 8.92151C30.3686 4.16781 26.4233 0.371735 21.6283 0.371735C17.838 0.371735 14.5845 2.73906 13.3825 6.07945C13.1101 6.03021 12.8297 6.00453 12.5438 6.00453C10.7877 6.00453 9.2422 6.97276 8.46453 8.41874L8.4145 8.41858C4.0755 8.41858 0.5 11.8544 0.5 16.1637C0.5 20.473 4.0755 23.9088 8.4145 23.9088V21.2935C5.45544 21.2935 3.11523 18.965 3.11523 16.1637C3.11523 13.3623 5.45544 11.0338 8.4145 11.0338C8.6661 11.0338 8.91334 11.0507 9.15421 11.0832L10.3219 11.2408L10.5998 10.0957C10.8001 9.27046 11.5776 8.61976 12.5438 8.61976C12.9388 8.61976 13.3021 8.72851 13.6079 8.91364L15.2689 9.91911L15.5762 8.00193ZM17.989 10.3968L24.2063 19.627H20.0399V27.8316H15.9376V19.627H11.7718L17.989 10.3968Z"
                                    fill="#505050" />
                            </svg>

            <svg  v-if="name === 'svg-upload-ok'"  xmlns="http://www.w3.org/2000/svg" width="35" height="28" viewBox="0 0 35 28"
                                transform="scale(0.8)" fill="none">
                                <path fill-rule="evenodd" clip-rule="evenodd"
                                    d="M15.5762 8.00193C16.0275 5.18599 18.5438 2.98696 21.6283 2.98696C25.0434 2.98696 27.7534 5.67576 27.7534 8.92151C27.7534 10.142 27.3744 11.275 26.721 12.2198L25.1418 14.5031L27.9079 14.2665C28.0152 14.2573 28.1243 14.2526 28.2352 14.2526C30.2817 14.2526 31.8827 15.8606 31.8827 17.773C31.8827 19.6855 30.2817 21.2935 28.2352 21.2935V23.9088C31.6615 23.9088 34.4979 21.1936 34.4979 17.773C34.4979 14.9068 32.5063 12.5358 29.8448 11.8427C30.1835 10.9313 30.3686 9.94727 30.3686 8.92151C30.3686 4.16781 26.4233 0.371735 21.6283 0.371735C17.838 0.371735 14.5845 2.73906 13.3825 6.07945C13.1101 6.03021 12.8297 6.00453 12.5438 6.00453C10.7877 6.00453 9.2422 6.97276 8.46453 8.41874L8.4145 8.41858C4.0755 8.41858 0.5 11.8544 0.5 16.1637C0.5 20.473 4.0755 23.9088 8.4145 23.9088V21.2935C5.45544 21.2935 3.11523 18.965 3.11523 16.1637C3.11523 13.3623 5.45544 11.0338 8.4145 11.0338C8.6661 11.0338 8.91334 11.0507 9.15421 11.0832L10.3219 11.2408L10.5998 10.0957C10.8001 9.27046 11.5776 8.61976 12.5438 8.61976C12.9388 8.61976 13.3021 8.72851 13.6079 8.91364L15.2689 9.91911L15.5762 8.00193ZM17.989 10.3968L24.2063 19.627H20.0399V27.8316H15.9376V19.627H11.7718L17.989 10.3968Z"
                                    fill="#c0c0c0" />
                            </svg>
            <svg v-if="name === 'svg-loader'"  xmlns="http://www.w3.org/2000/svg" width="34" height="28" fill="none"
                    transform="scale(0.8)" viewBox="0 0 34 28">
                    <path fill-rule="evenodd" clip-rule="evenodd"
                        d="M15.0762 8.00193C15.5275 5.18599 18.0438 2.98696 21.1283 2.98696C24.5434 2.98696 27.2534 5.67576 27.2534 8.92151C27.2534 10.142 26.8744 11.275 26.221 12.2198L24.6418 14.5031L27.4079 14.2665C27.5152 14.2573 27.6243 14.2526 27.7352 14.2526C29.7817 14.2526 31.3827 15.8606 31.3827 17.773C31.3827 19.6855 29.7817 21.2935 27.7352 21.2935V23.9088C31.1615 23.9088 33.9979 21.1936 33.9979 17.773C33.9979 14.9068 32.0063 12.5358 29.3448 11.8427C29.6835 10.9313 29.8686 9.94727 29.8686 8.92151C29.8686 4.16781 25.9233 0.371735 21.1283 0.371735C17.338 0.371735 14.0845 2.73906 12.8825 6.07945C12.6101 6.03021 12.3297 6.00453 12.0438 6.00453C10.2877 6.00453 8.7422 6.97276 7.96453 8.41874L7.9145 8.41858C3.5755 8.41858 0 11.8544 0 16.1637C0 20.473 3.5755 23.9088 7.9145 23.9088V21.2935C4.95544 21.2935 2.61523 18.965 2.61523 16.1637C2.61523 13.3623 4.95544 11.0338 7.9145 11.0338C8.1661 11.0338 8.41334 11.0507 8.65421 11.0832L9.82195 11.2408L10.0998 10.0957C10.3001 9.27046 11.0776 8.61976 12.0438 8.61976C12.4388 8.61976 12.8021 8.72851 13.1079 8.91364L14.7689 9.91911L15.0762 8.00193ZM17.4892 27.8316L11.272 18.6014H15.4383L15.4383 10.3968H19.5407L19.5407 18.6014H23.7065L17.4892 27.8316Z"
                        fill="#505050" />
                </svg>
            <svg v-if="name === 'svg-toReturn'"  xmlns="http://www.w3.org/2000/svg" width="20" height="25" fill="none" viewBox="0 0 20 25"
                    transform="scale(0.8)">
                    <path fill-rule="evenodd" clip-rule="evenodd"
                        d="M7.03085 0L7.9652 1.98877H8.6247L8.62557 3.28822L8.62552 4.58768H7.96578L7.03085 6.57645L0 3.28822L7.03085 0ZM8.62557 3.28822L8.62552 4.58768C13.4499 4.58768 17.3952 8.55628 17.3952 13.4944C17.3952 18.4325 13.4499 22.4011 8.62557 22.4011H6.5417V25H8.62557C14.9265 25 20 19.8297 20 13.4944C20 7.15907 14.9256 1.98877 8.6247 1.98877L8.62557 3.28822Z"
                        fill="#505050" />
                </svg>
            <svg v-if="name === 'svg-unReturn'"  xmlns="http://www.w3.org/2000/svg" width="20" height="25" viewBox="0 0 20 25"
                    transform="scale(0.8)" fill="none">
                    <path fill-rule="evenodd" clip-rule="evenodd"
                        d="M12.9692 0L12.0348 1.98877H11.3753L11.3744 3.28822L11.3745 4.58768H12.0342L12.9692 6.57645L20 3.28822L12.9692 0ZM11.3744 3.28822L11.3745 4.58768C6.55013 4.58768 2.60483 8.55628 2.60483 13.4944C2.60483 18.4325 6.55008 22.4011 11.3744 22.4011H13.4583V25H11.3744C5.07354 25 1.33681e-07 19.8297 1.33681e-07 13.4944C1.33681e-07 7.15907 5.07441 1.98877 11.3753 1.98877L11.3744 3.28822Z"
                        fill="#505050" />
                </svg>

            <svg v-if="name === 'svg-logo'"  width="55" height="50" xmlns="http://www.w3.org/2000/svg">
                            <!-- 主體 -->
                            <defs>
                                <linearGradient id="grad10" x1="0" y1="0" x2="1" y2="1">
                                    <stop offset="0%" stop-color="#FFF9C4" />
                                    <stop offset="100%" stop-color="#FFEB3B" />
                                </linearGradient>
                                <linearGradient id="grad12" x1="0" y1="0" x2="1" y2="1">
                                    <stop offset="0%" stop-color="#FFF9C4" />
                                    <stop offset="100%" stop-color="#FFEB3B" />
                                </linearGradient>
                                <linearGradient id="grad11" x1="0" y1="0" x2="1" y2="1">
                                    <stop offset="0%" stop-color="#FFEB3B" />
                                    <stop offset="100%" stop-color="#FFEB3B" />
                                </linearGradient>
                            </defs>
                            <!-- 整合圖形符號 -->
                            <g transform="scale(0.3)">
                                <rect x="20" y="20" rx="2" ry="2" width="100" height="100" fill="url(#grad10)"
                                    stroke="#FBC02D" stroke-width="2" />
                                <rect x="20" y="20" rx="2" ry="2" width="100" height="100" fill="url(#grad12)"
                                    stroke="#FBC02D" stroke-width="0" />
                                <rect x="20" y="20" rx="2" width="100" height="20" fill="url(#grad11)"
                                    stroke="#FBC02D" stroke-width="0" />
                                <!-- 節點沿邊排列 -->

                                <circle cx="70" cy="20" r="5" fill="#F57F17" />
                                <circle cx="120" cy="70" r="5" fill="#F57F17" />
                                <circle cx="70" cy="120" r="5" fill="#F57F17" />
                                <!-- 連線 -->
                                <line x1="70" y1="20" x2="120" y2="70" stroke="#F57F17" stroke-width="2" />
                                <line x1="120" y1="70" x2="70" y2="120" stroke="#F57F17" stroke-width="2" />
                            </g>
                        </svg>

                        <!-- svgIcon:上一頁 -->  
                            <svg v-if="name === 'svg-previousPage'"  xmlns="http://www.w3.org/2000/svg" width="19" height="28" viewBox="0 0 19 28"
                                transform="scale(0.8)" fill="none">
                                <path fill-rule="evenodd" clip-rule="evenodd"
                                    d="M0.685302 14L16.278 0.733192L18.2221 3.01807L5.31482 14L18.2221 24.9819L16.278 27.2668L0.685302 14Z"
                                    fill="#505050" />
                            </svg>

                        <!-- svgIcon:下載 -->  
                         <svg v-if="name === 'svg-download'"  xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                            <path fill-rule="evenodd" clip-rule="evenodd"
                                d="M14 0V10V18.5858L10.7071 15.2929L9.29289 16.7071L14.2929 21.7071L15 22.4142L15.7071 21.7071L20.7071 16.7071L19.2929 15.2929L16 18.5858V10V0H14ZM2 13.5C2 11.8431 3.34315 10.5 5 10.5H8V8.5H5C2.23858 8.5 0 10.7386 0 13.5V23C0 25.7614 2.23858 28 5 28H25C27.7614 28 30 25.7614 30 23V13.5C30 10.7386 27.7614 8.5 25 8.5H22V10.5H25C26.6569 10.5 28 11.8431 28 13.5V23C28 24.6569 26.6569 26 25 26H5C3.34315 26 2 24.6569 2 23V13.5Z"
                                fill="#A7A7A7" />
                        </svg>

                         <!-- svgIcon:更多 -->   
                        <svg v-if="name === 'svg-more'"  xmlns="http://www.w3.org/2000/svg" width="26" height="5" viewBox="0 0 26 5" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M0 2C0 0.895432 0.895386 0 2 0H4C5.10461 0 6 0.895432 6 2V3C6 4.10457 5.10461 5 4 5H2C0.895386 5 0 4.10457 0 3V2ZM10 2C10 0.895432 10.8954 0 12 0H14C15.1046 0 16 0.895432 16 2V3C16 4.10457 15.1046 5 14 5H12C10.8954 5 10 4.10457 10 3V2ZM22 0C20.8954 0 20 0.895432 20 2V3C20 4.10457 20.8954 5 22 5H24C25.1046 5 26 4.10457 26 3V2C26 0.895432 25.1046 0 24 0H22Z"
                            fill="#505050" />
                        </svg>

                         <!-- svgIcon:新增便利貼 -->    
                        <svg v-if="name === 'svg-addNode'" xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                            <path fill-rule="evenodd" clip-rule="evenodd"
                                d="M4 0C1.79086 0 0 1.79086 0 4V24C0 26.2091 1.79086 28 4 28H26C28.2091 28 30 26.2091 30 24V4C30 1.79086 28.2091 0 26 0H4ZM2 4C2 2.89543 2.89543 2 4 2H26C27.1046 2 28 2.89543 28 4V24C28 25.1046 27.1046 26 26 26H4C2.89543 26 2 25.1046 2 24V4ZM5 5H25V3H5V5ZM14 17H8V15H14V9H16V15H22V17H16V23H14V17Z"
                                fill="#505050" />
                        </svg>

                        <!-- svgIcon:新增圖表便利貼 -->  
                        <svg v-if="name === 'svg-addChartNode'"  xmlns="http://www.w3.org/2000/svg" width="31" height="28" viewBox="0 0 31 28" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M6 3C4.34315 3 3 4.34315 3 6V15C3 16.3062 3.83481 17.4175 5 17.8293V15V7V6C5 5.44772 5.44772 5 6 5H7H18H20.8293C20.4175 3.83481 19.3062 3 18 3H6Z"
                            fill="#505050" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M9 6C7.34315 6 6 7.34315 6 9V19C6 20.3062 6.83481 21.4175 8 21.8293V19V10V9C8 8.44772 8.44772 8 9 8H10H22H24.8293C24.4175 6.83481 23.3062 6 22 6H9Z"
                            fill="#505050" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M9 12C9 10.3431 10.3431 9 12 9H25C26.6569 9 28 10.3431 28 12V22C28 23.6569 26.6569 25 25 25H12C10.3431 25 9 23.6569 9 22V12ZM12 11C11.4477 11 11 11.4477 11 12V22C11 22.5523 11.4477 23 12 23H25C25.5523 23 26 22.5523 26 22V12C26 11.4477 25.5523 11 25 11H12Z"
                            fill="#505050" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M10 0H2C0.895447 0 0 0.895432 0 2V10H2V2H10V0ZM29 10V2H21V0H29C30.1046 0 31 0.89543 31 2V10H29ZM21 26H29V18H31V26C31 27.1046 30.1046 28 29 28H21V26ZM2 18V26H10V28H2C0.895447 28 0 27.1046 0 26V18H2Z"
                            fill="#505050" />
                        </svg>

                        <!-- svgIcon:刪除便利貼 -->  
                        <svg  v-if="name === 'svg-deleteNode'" xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M0 4C0 1.79086 1.79086 0 4 0H26C28.2091 0 30 1.79086 30 4V10V11.5V12V19H28V12H26V14H24V12H22V18H20V14.5H16V16V17H15H14V25H12V17H10V22H8V17H6.5V19.5V20.5H5.5H2V23H0V20.5V20V18.5V4ZM28 4V10H20H19V11V12.5H15H14V13.5V15H5.5H4.5V16V18.5H2V4C2 2.89543 2.89543 2 4 2H26C27.1046 2 28 2.89543 28 4ZM5 5H25V3H5V5ZM0 24V26H2V24H0ZM16 18V20H18V18H16ZM28 21.5V25.5H30V21.5H28ZM24 20H26V16H24V20ZM20 24H22V20H20V24ZM4 22V28H6V22H4ZM16 22V28H18V22H16ZM24 22V27H26V22H24ZM8 24V27H10V24H8Z"
                            fill="#505050" />
                        </svg>

                        <!-- svgIcon:便利貼換色:粉紅 -->  
                        <svg v-if="name === 'svg-nodeColorPink'"  xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                        <path
                            d="M1 4C1 2.34315 2.34315 1 4 1H26C27.6569 1 29 2.34315 29 4V24C29 25.6569 27.6569 27 26 27H4C2.34315 27 1 25.6569 1 24V4Z"
                            fill="#ffc0cb" />
                        <path
                            d="M4 2H26V0H4V2ZM28 4V24H30V4H28ZM26 26H4V28H26V26ZM2 24V4H0V24H2ZM4 26C2.89543 26 2 25.1046 2 24H0C0 26.2091 1.79086 28 4 28V26ZM28 24C28 25.1046 27.1046 26 26 26V28C28.2091 28 30 26.2091 30 24H28ZM26 2C27.1046 2 28 2.89543 28 4H30C30 1.79086 28.2091 0 26 0V2ZM4 0C1.79086 0 0 1.79086 0 4H2C2 2.89543 2.89543 2 4 2V0Z"
                            fill="#CFCFCF" />
                        <path d="M5 4H25" stroke="#CFCFCF" stroke-width="2" />
                        </svg>

                        <!-- svgIcon:便利貼換色:粉綠 -->  
                        <svg v-if="name === 'svg-nodeColorGreen'"  xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                        <path
                            d="M1 4C1 2.34315 2.34315 1 4 1H26C27.6569 1 29 2.34315 29 4V24C29 25.6569 27.6569 27 26 27H4C2.34315 27 1 25.6569 1 24V4Z"
                            fill="#D3ED7F" />
                        <path
                            d="M4 2H26V0H4V2ZM28 4V24H30V4H28ZM26 26H4V28H26V26ZM2 24V4H0V24H2ZM4 26C2.89543 26 2 25.1046 2 24H0C0 26.2091 1.79086 28 4 28V26ZM28 24C28 25.1046 27.1046 26 26 26V28C28.2091 28 30 26.2091 30 24H28ZM26 2C27.1046 2 28 2.89543 28 4H30C30 1.79086 28.2091 0 26 0V2ZM4 0C1.79086 0 0 1.79086 0 4H2C2 2.89543 2.89543 2 4 2V0Z"
                            fill="#CFCFCF" />
                        <path d="M5 4H25" stroke="#CFCFCF" stroke-width="2" />
                        </svg>

                        <!-- svgIcon:便利貼換色:粉藍 -->  
                               <svg v-if="name === 'svg-nodeColorBlue'"  xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                        <path
                            d="M1 4C1 2.34315 2.34315 1 4 1H26C27.6569 1 29 2.34315 29 4V24C29 25.6569 27.6569 27 26 27H4C2.34315 27 1 25.6569 1 24V4Z"
                            fill="#CEEBFD" />
                        <path
                            d="M4 2H26V0H4V2ZM28 4V24H30V4H28ZM26 26H4V28H26V26ZM2 24V4H0V24H2ZM4 26C2.89543 26 2 25.1046 2 24H0C0 26.2091 1.79086 28 4 28V26ZM28 24C28 25.1046 27.1046 26 26 26V28C28.2091 28 30 26.2091 30 24H28ZM26 2C27.1046 2 28 2.89543 28 4H30C30 1.79086 28.2091 0 26 0V2ZM4 0C1.79086 0 0 1.79086 0 4H2C2 2.89543 2.89543 2 4 2V0Z"
                            fill="#CFCFCF" />
                        <path d="M5 4H25" stroke="#CFCFCF" stroke-width="2" />
                        </svg>

                        <!-- svgIcon:便利貼換色:粉黃 -->  
                        <svg v-if="name === 'svg-nodeColorYellow'"  xmlns="http://www.w3.org/2000/svg" width="30" height="28" viewBox="0 0 30 28" fill="none">
                        <path
                            d="M1 4C1 2.34315 2.34315 1 4 1H26C27.6569 1 29 2.34315 29 4V24C29 25.6569 27.6569 27 26 27H4C2.34315 27 1 25.6569 1 24V4Z"
                            fill="#FFF8CA" />
                        <path
                            d="M4 2H26V0H4V2ZM28 4V24H30V4H28ZM26 26H4V28H26V26ZM2 24V4H0V24H2ZM4 26C2.89543 26 2 25.1046 2 24H0C0 26.2091 1.79086 28 4 28V26ZM28 24C28 25.1046 27.1046 26 26 26V28C28.2091 28 30 26.2091 30 24H28ZM26 2C27.1046 2 28 2.89543 28 4H30C30 1.79086 28.2091 0 26 0V2ZM4 0C1.79086 0 0 1.79086 0 4H2C2 2.89543 2.89543 2 4 2V0Z"
                            fill="#CFCFCF" />
                        <path d="M5 4H25" stroke="#CFCFCF" stroke-width="2" />
                        </svg>

                        <!-- svgIcon:線條換色:粉紅 -->
                        <svg v-if="name === 'svg-lineColorPink'"  xmlns="http://www.w3.org/2000/svg" width="31" height="27" viewBox="0 0 31 27" fill="none">
                            <path
                                d="M1 1C8.49996 0.999996 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 23 25.5 30 25"
                                stroke="#FCAFAA" stroke-width="2" stroke-linecap="round" />
                        </svg>

                        <!-- svgIcon:線條換色:粉綠 -->
                        <svg v-if="name === 'svg-lineColorGreen'"  xmlns="http://www.w3.org/2000/svg" width="31" height="27" viewBox="0 0 31 27" fill="none">
                            <path
                                d="M1 1C8.49996 0.999996 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 23 25.5 30 25"
                                stroke="#C7DF7A" stroke-width="2" stroke-linecap="round" />
                        </svg>
                        
                        <!-- svgIcon:線條換色:粉藍 -->
                        <svg v-if="name === 'svg-lineColorBlue'"  xmlns="http://www.w3.org/2000/svg" width="31" height="27" viewBox="0 0 31 27" fill="none">
                            <path
                                d="M1 1C8.49996 0.999996 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 23 25.5 30 25"
                                stroke="#ADD8E6" stroke-width="2" stroke-linecap="round" />
                        </svg>

                        <!-- svgIcon:線條換色:橘黃 -->
                        <svg v-if="name === 'svg-lineColorYellow'"  xmlns="http://www.w3.org/2000/svg" width="31" height="27" viewBox="0 0 31 27" fill="none">
                            <path
                                d="M1 1C8.49996 0.999996 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 23 25.5 30 25"
                                stroke="#FFB53E" stroke-width="2" stroke-linecap="round" />
                        </svg>


                            <!-- svgIcon:線條類型:實線 -->
                        <svg v-if="name === 'svg-lineTypeEntity'"  xmlns="http://www.w3.org/2000/svg" width="31" height="26" viewBox="0 0 31 26" fill="none">
                            <path
                                d="M7.50004 3.99999C15 3.99999 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 16.5 22.5 23.5 22"
                                stroke="#A7A7A7" stroke-width="2" />
                            <circle cx="4" cy="4" r="3" stroke="#A7A7A7" stroke-width="2" />
                            <circle cx="27" cy="22" r="3" stroke="#A7A7A7" stroke-width="2" />
                        </svg>


                        <!-- svgIcon:線條類型:中空線 -->
                        <svg v-if="name === 'svg-lineTypeHollow'"  xmlns="http://www.w3.org/2000/svg" width="31" height="26" viewBox="0 0 31 26" fill="none">
                            <path
                                d="M7.50004 3.99999C15 3.99999 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 16.5 22.5 23.5 22"
                                stroke="#A7A7A7" stroke-width="2" stroke-dasharray="6 2" />
                            <circle cx="4" cy="4" r="3" stroke="#A7A7A7" stroke-width="2" />
                            <circle cx="27" cy="22" r="3" stroke="#A7A7A7" stroke-width="2" />
                        </svg>



                        <!-- svgIcon:線條類型:虛線 -->
                        <svg v-if="name === 'svg-lineTypeDottedLine'"  xmlns="http://www.w3.org/2000/svg" width="31" height="26" viewBox="0 0 31 26" fill="none">
                            <path
                                d="M7.50004 3.99999C15 3.99999 23.5 3.49999 23.5 8.99999C23.5 14.5 7.50004 11.5 7.5 17C7.49996 22.5 16.5 22.5 23.5 22"
                                stroke="#A7A7A7" stroke-width="2" stroke-dasharray="2 2" />
                            <circle cx="4" cy="4" r="3" stroke="#A7A7A7" stroke-width="2" />
                            <circle cx="27" cy="22" r="3" stroke="#A7A7A7" stroke-width="2" />
                        </svg>


                        <!-- svgIcon:右鍵選單:粉紅 -->
                        <svg v-if="name === 'svg-lfetMenuPink'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" transform="scale(1)">
                            <circle cx="12" cy="12" r="11" fill="#FFE6EB" stroke="#CFCFCF" stroke-width="2" />
                        </svg>


                        <!-- svgIcon:右鍵選單:粉綠 -->
                        <svg v-if="name === 'svg-lfetMenuGreen'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" transform="scale(1)">
                            <circle cx="12" cy="12" r="11" fill="#F7FFDB" stroke="#CFCFCF" stroke-width="2" />
                        </svg>


                            <!-- svgIcon:右鍵選單:粉藍 -->
                        <svg v-if="name === 'svg-lfetMenuBlue'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" transform="scale(1)">
                            <circle cx="12" cy="12" r="11" fill="#CEEBFD" stroke="#CFCFCF" stroke-width="2" />
                        </svg>


                        <!-- svgIcon:右鍵選單:粉黃 -->
                        <svg v-if="name === 'svg-lfetMenuYellow'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" transform="scale(1)">
                            <circle cx="12" cy="12" r="11" fill="#FFF8CA" stroke="#CFCFCF" stroke-width="2" />
                        </svg>



    `,
        };

        // 圖表內使用的SVG
        const SvgMain = {
            // v-if="name === 'svg-map'" 
            // <svg-main name="svg-map"></svg-main>
            props: ['name'], // 動態傳入 SVG 名稱 
            template: `
                    
             <!-- svgIcon:圖表:綠 -->
            <svg v-if="name === 'svg-chartColorGreen'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 7 24 24" fill="none" transform="scale(1.6)">
                    <circle cx="12" cy="12" r="11" fill="#F7FFDB" stroke="#CFCFCF"
                    stroke-width="2" />
            </svg>

             <!-- svgIcon:圖表:粉紅 -->
            <svg v-if="name === 'svg-chartColorPink'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 7 24 24" fill="none" transform="scale(1.6)">
                    <circle cx="12" cy="12" r="11" fill="#FFE6EB" stroke="#CFCFCF"
                        stroke-width="2" />
                </svg>

             <!-- svgIcon:圖表:藍 -->
            <svg v-if="name === 'svg-chartColorBlue'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                    viewBox="0 7 24 24" fill="none" transform="scale(1.6)">
                    <circle cx="12" cy="12" r="11" fill="#E5F5FF" stroke="#CFCFCF"
                        stroke-width="2" />
                </svg>

             <!-- svgIcon:圖表:白 -->
            <svg v-if="name === 'svg-chartColorWhite'"  xmlns="http://www.w3.org/2000/svg" width="24" height="24"
                viewBox="0 7 24 24" fill="none" transform="scale(1.6)">
                <circle cx="12" cy="12" r="11" fill="#fdfdfd" stroke="#CFCFCF"
                    stroke-width="2" />
            </svg>
                        

    `,
        };

        const app = Vue.createApp({

            data() {
                return {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    noteWidth: 130,
                    noteHeight: 120,
                    center: { x: window.innerWidth / 2, y: window.innerHeight / 2 },
                    // 初始便利貼，預設顏色為 lightyellow，並加入 selected 屬性
                    nodes: [],
                    // 連線資料，加入 selected 屬性
                    connections: [],
                    contextMenu: {
                        visible: false,
                        x: 0,
                        y: 0,
                        type: '', // 'blank'、'node'、'curve'
                        node: null,
                        connection: null
                    },
                    connectionStartNode: null,
                    nextNodeId: 6,
                    // 框選用的選取框資料
                    selectionBox: {
                        active: false,
                        startX: 0,
                        startY: 0,
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0,
                    },
                    // 群組拖曳用：記錄目前正在拖曳的便利貼集合及起始點
                    draggingNodes: [],
                    dragStart: { x: 0, y: 0 },

                    // 新增歷史記錄相關屬性
                    history: [], // 存放歷史狀態
                    currentIndex: -1, // 當前狀態指針

                    /* 畫板平移與縮放 */
                    boardOffset: { x: 0, y: 0 },
                    scale: 1,
                    /* 右鍵平移狀態 */
                    isRightPanning: false,
                    rightPanStart: { x: 0, y: 0 },
                    rightPanMoved: false,

                    /* 使用者與畫板ID */
                    userId: '',
                    boardId: '',
                    boardName: '',
                    startLocalStorage: false,

                    editName: false,

                    // Chart圖表用變量
                    resizingNode: null,
                    resizeStartX: 0,
                    resizeStartY: 0,
                    chartInstances: {}, // 儲存每個圖表實例

                    // 線條優化
                    draggingArrow: null, // 正在拖移的箭頭（連線）
                    dragArrowStartY: 0,  // 拖移起點 Y 座標
                    //臨時線條拖移
                    hoveredNode: null,
                    tempConnection: {
                        active: false,
                        path: '',
                        startNode: null,
                        startX: 0,
                        startY: 0,
                    },
                    isMobile: false, // 是否為移動設備
                    lastPointerDown: { time: 0, x: 0, y: 0, target: null }, // 記錄最近一次 pointerdown
                    lastClick: { time: 0, node: null }, // 記錄上一次點擊的資訊
                    touchPoints: new Map(), // 記錄觸控點，確保可以正確追蹤手指的移動。
                    processedEvents: new Set(), // 用於避免重複處理事件
                    lastDistance: null, // 記錄雙指間距離
                    isDragging: false,

                    isDark: false, //黑暗模式

                    uploadTimer: null, // 用於上傳的存儲計時器
                    isAutoUpload: false,

                }
            },
            // 生命週期 : 起始
            created() {
                const vm = this;
                // 設備檢測邏輯
                const userAgent = navigator.userAgent.toLowerCase();
                const isTouchDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
                const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
                this.isMobile = isTouchDevice || isCoarsePointer || ('ontouchstart' in window);
                // 設備檢測邏輯


                vm.boardId = localStorage.getItem('boardId');
                vm.boardName = localStorage.getItem('boardName');

                if (vm.boardId == "newBoard") {
                    vm.boardId = Math.random().toString(36).substring(2, 12);
                    localStorage.setItem('boardId', vm.boardId)

                    vm.nodes = [
                        { boardId: vm.boardId, type: 'general', id: 1, count: 1, label: '便條紙 1', angle: 0, color: '#FFF8CA', colorTop: '#FFF4B2', selected: false, total: 1, connectionsOut: [], connectionsIn: [], operation: "sum", connections: [] },
                        { boardId: vm.boardId, type: 'general', id: 2, count: 2, label: '便條紙 2', angle: 90, color: '#D3ED7F', colorTop: '#C7DF7A', selected: false, total: 2, connectionsOut: [], connectionsIn: [], operation: "sum", connections: [] },
                        { boardId: vm.boardId, type: 'general', id: 3, count: 3, label: '便條紙 3', angle: 180, color: '#ffc0cb', colorTop: '#FCAFAA', selected: false, total: 3, connectionsOut: [], connectionsIn: [], operation: "sum", connections: [] },
                        { boardId: vm.boardId, type: 'general', id: 4, count: 4, label: '便條紙 4', angle: 270, color: '#CEEBFD', colorTop: '#ADD8E6', selected: false, total: 4, connectionsOut: [], connectionsIn: [], operation: "sum", connections: [] },
                    ];

                    // 根據角度初始化便利貼的位置
                    const radius = 200;
                    this.nodes.forEach(node => {
                        const radian = (node.angle * Math.PI) / 180;
                        node.x = this.center.x + radius * Math.cos(radian);
                        node.y = this.center.y + radius * Math.sin(radian);
                        node.editing = false;
                        this.computeTotal(node);
                    });
                } else {
                    vm.nodes = [];
                    vm.connections = [];

                }
            },
            // 生命週期 : 初始化完成後
            mounted() {
                const vm = this;

                vm.checkuid();

                // 添加 pagehide 事件（移動端，尤其是 iOS）目前看好像沒用，後續再決定去留
                window.addEventListener('pagehide', this.handlePageHide);

                // 添加 beforeunload 事件（桌面端可用）
                window.addEventListener('beforeunload', this.handleBeforeUnload);

                // 添加 visibilitychange 事件（檢測頁面隱藏）
                document.addEventListener('visibilitychange', this.handleVisibilityChange);

                window.addEventListener('keydown', this.handleKeyDown);

                //儲存狀態
                this.saveState()

            },
            beforeDestroy() {
                // 移除事件監聽器
                window.removeEventListener('beforeunload', this.handleBeforeUnload);
                window.removeEventListener('pagehide', this.handlePageHide);
                document.removeEventListener('visibilitychange', this.handleVisibilityChange);
            },
            beforeUnmount() {
                window.removeEventListener('keydown', this.handleKeyDown);
            },
            // 監視
            watch: {
                nodes: {
                    // 深層監聽，保留方法handler與deep是搭配使用的
                    handler(newNodes) {
                        // 存放到localStorage裡
                        if (this.startLocalStorage) {
                            localStorage.setItem('nodes', JSON.stringify(newNodes));
                        }

                        // 清除現有的計時器
                        if (this.uploadTimer) {
                            clearTimeout(this.uploadTimer);
                            this.isAutoUpload = false;
                        }

                        // 自動存檔區分電腦端與移動端，移動端無法抓取到存檔，所以時間減短至修改後30秒未動就存檔
                        if (!this.isMobile) {
                            // 一有更動就設置新的2分鐘計時器
                            this.uploadTimer = setTimeout(() => {
                                this.nodesUpload();
                                this.isAutoUpload = true;
                            }, 300000); // 2分鐘 = 120000毫秒

                        } else {
                            // 一有更動就設置新的2分鐘計時器
                            this.uploadTimer = setTimeout(() => {
                                this.nodesUpload();
                                this.isAutoUpload = true;
                            }, 30000); // 30秒 = 30000毫秒
                        }

                    },
                    deep: true,
                },
                connections: {
                    // 深層監聽，保留方法handler與deep是搭配使用的
                    handler(newConnections) {
                        if (this.startLocalStorage) {
                            localStorage.setItem('connections', JSON.stringify(newConnections));
                        }
                    },
                    deep: true,
                },
            },
            // 計算、運算
            computed: {

                svgStyle() {
                    return this.isMobile ? { touchAction: 'none' } : {};
                    // 是否為移動端
                },

                foreignObjectTransformStyle() {
                    // 僅在移動端應用 transform，避免桌面端受到影響
                    if (!this.isMobile) return {};
                    return {
                        transform: `translate(${this.boardOffset.x}px, ${this.boardOffset.y}px) scale(${this.scale})`,
                        transformOrigin: '0 0', // 確保縮放從左上角開始
                    };
                },

                selectedNode() {
                    return this.nodes.some(n => n.selected && n.type !== "chart")
                },
                selectedChert() {
                    return this.nodes.some(n => n.selected && n.type === "chart")
                },
                selectedConn() {
                    // some() 有任一個 node.selected 為 true 就設為 true，否則 false
                    return this.connections.some(c => c.selected)
                },
                computedToolbarHeight() {
                    if (this.selectedNode && this.selectedConn) {
                        return 496
                    } else if (this.selectedConn) {
                        return 368
                    } else if (this.selectedNode) {
                        return 256
                    } else if (this.selectedChert) {
                        return 122
                    } else {
                        return 82
                    }
                },
                /* 畫板 transform */
                boardTransform() {
                    return `translate(${this.boardOffset.x}, ${this.boardOffset.y}) scale(${this.scale})`;
                },
                /* 計算可見範圍（畫板座標） */
                visibleRect() {
                    const left = -this.boardOffset.x / this.scale;
                    const top = -this.boardOffset.y / this.scale;
                    const right = left + this.width / this.scale;
                    const bottom = top + this.height / this.scale;
                    return { left, top, right, bottom };
                },
                /* 若有便條紙超出可見範圍則顯示浮動箭頭 */
                showLeftArrow() {
                    return this.nodes.some(n => n.x + this.noteWidth / 2 < this.visibleRect.left);
                },
                showRightArrow() {
                    return this.nodes.some(n => n.x - this.noteWidth / 2 > this.visibleRect.right);
                },
                showTopArrow() {
                    return this.nodes.some(n => n.y + this.noteHeight / 2 < this.visibleRect.top);
                },
                showBottomArrow() {
                    return this.nodes.some(n => n.y - this.noteHeight / 2 > this.visibleRect.bottom);
                }
            },

            // 方法函式
            methods: {
                /* ================ 移動相關 ==================== */



                // 滾輪縮放
                handleWheel(event) {
                    const zoomFactor = 1 - event.deltaY * 0.001;
                    const rect = event.currentTarget.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    const prevScale = this.scale;
                    this.scale *= zoomFactor;
                    this.scale = Math.max(0.5, Math.min(2, this.scale));
                    // 使縮放以滑鼠位置為中心
                    this.boardOffset.x -= (mouseX / prevScale - mouseX / this.scale);
                    this.boardOffset.y -= (mouseY / prevScale - mouseY / this.scale);
                },

                /* ===== 左鍵平移與一般 mousemove ===== */
                handleMouseMove(event) {
                    // 若正在左鍵平移，更新 boardOffset
                    if (this.isRightPanning) {
                        const dx = event.clientX - this.rightPanStart.x;
                        const dy = event.clientY - this.rightPanStart.y;
                        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                            this.rightPanMoved = true;
                        }
                        this.boardOffset.x += dx;
                        this.boardOffset.y += dy;
                        this.rightPanStart = { x: event.clientX, y: event.clientY };
                    }
                },

                /* ===== mouseup 處理 ===== */
                handleMouseUp(event) {
                    if (event.button === 0) {
                        if (this.isRightPanning) {
                            // 若未拖曳則顯示背景右鍵選單
                            if (!this.rightPanMoved && event.button === 2) {
                                this.contextMenu.visible = true;
                                this.contextMenu.x = event.clientX;
                                this.contextMenu.y = event.clientY;
                                this.contextMenu.type = 'blank';
                                this.contextMenu.node = null;
                                this.contextMenu.connection = null;
                            }
                            this.isRightPanning = false;
                        };
                    }
                },

                // 對應背景網格
                /* ===== 左鍵平移：背景 Pointer ===== */
                handleBackgroundPointerDown(event) {
                    // event.preventDefault();
                    this.touchPoints.set(event.pointerId, { x: event.clientX, y: event.clientY });
                    if (event.button === 0 && !event.ctrlKey) {
                        this.isRightPanning = true;
                        this.rightPanStart = { x: event.clientX, y: event.clientY };
                        this.rightPanMoved = false;
                    }

                    // 記錄 pointerdown 事件
                    this.lastPointerDown = {
                        time: Date.now(),
                        x: event.clientX,
                        y: event.clientY,
                        target: event.target
                    };

                    if (event.pointerType === 'touch' && this.touchPoints.size === 1) {
                        this.lastTouchTime = Date.now();
                        this.longPressTimer = setTimeout(() => {
                            this.handleSvgContextMenu(event);
                        }, this.longPressThreshold);
                    }

                    if (event.pointerType === 'touch' && this.touchPoints.size === 2) {
                        clearTimeout(this.longPressTimer);
                        this.isPanning = true;
                        const touches = Array.from(this.touchPoints.values());
                        const center = this.getTouchCenter(touches[0], touches[1]);
                        this.panStart = { x: center.x, y: center.y };
                        this.lastDistance = this.getTouchDistance(touches[0], touches[1]);
                    }

                },

                // Pointer 框選 對應SVG
                handleSvgPointerDown(event) {
                    this.touchPoints.set(event.pointerId, { x: event.clientX, y: event.clientY });
                    this.lastPointerDown = {
                        time: Date.now(),
                        x: event.clientX,
                        y: event.clientY,
                        target: event.target
                    };

                    if (event.button === 0 && !event.ctrlKey) {
                        this.nodes.forEach(n => n.selected = false);
                        this.connections.forEach(n => n.selected = false);
                    } else if (event.button === 0 && event.ctrlKey) {
                        if (event.target.id === 'mindmapSvg' ||
                            (event.target.tagName === 'rect' && event.target.getAttribute('fill') === 'url(#grid)')) {

                            if (!event.shiftKey) {
                                this.nodes.forEach(n => n.selected = false);
                                this.connections.forEach(n => n.selected = false);
                            }

                            // 如果未按 Shift 則清除先前的選取
                            this.selectionBox.active = true;
                            this.editName = false;

                            // 獲取 SVG 元素
                            const svg = document.getElementById('mindmapSvg');
                            const point = svg.createSVGPoint();
                            point.x = event.clientX;
                            point.y = event.clientY;

                            // 將視窗坐標轉換為 SVG 坐標
                            const ctm = svg.getScreenCTM();
                            let svgStartX = (point.x - ctm.e) / ctm.a;
                            let svgStartY = (point.y - ctm.f) / ctm.d;

                            // 考慮畫板縮放和位移
                            svgStartX = (svgStartX - this.boardOffset.x) / this.scale;
                            svgStartY = (svgStartY - this.boardOffset.y) / this.scale;

                            this.selectionBox.startX = svgStartX;
                            this.selectionBox.startY = svgStartY;
                            this.selectionBox.x = svgStartX;
                            this.selectionBox.y = svgStartY;
                            this.selectionBox.width = 0;
                            this.selectionBox.height = 0;
                            this.draggingNodes = [];
                        }
                    }
                },

                // 拖曳中：若正進行群組移動，則更新所有拖曳便利貼的位置；否則更新框選矩形
                dragMove(event) {
                    this.touchPoints.set(event.pointerId, { x: event.clientX, y: event.clientY });

                    // 處理臨時連線拖動
                    if (this.tempConnection.active) {
                        const svg = document.getElementById('mindmapSvg');
                        const point = svg.createSVGPoint();
                        point.x = event.clientX;
                        point.y = event.clientY;

                        const ctm = svg.getScreenCTM();
                        let svgX = (point.x - ctm.e) / ctm.a;
                        let svgY = (point.y - ctm.f) / ctm.d;

                        svgX = (svgX - this.boardOffset.x) / this.scale;
                        svgY = (svgY - this.boardOffset.y) / this.scale;

                        if (isNaN(svgX) || isNaN(svgY)) {
                            console.warn('Invalid SVG coordinates:', svgX, svgY);
                            return;
                        }

                        const startX = this.tempConnection.startX;
                        const startY = this.tempConnection.startY;
                        if (isNaN(startX) || isNaN(startY)) {
                            console.warn('Invalid start coordinates:', startX, startY);
                            return;
                        }

                        const endX = svgX;
                        const endY = svgY;
                        const mx = (startX + endX) / 2, my = (startY + endY) / 2;
                        const dx = endX - startX, dy = endY - startY;
                        const len = Math.sqrt(dx * dx + dy * dy);
                        let offset = 30;
                        if (len === 0) offset = 0;
                        const px = -dy / (len || 1), py = dx / (len || 1);
                        const cx = mx + px * offset, cy = my + py * offset;

                        this.tempConnection.path = `M ${startX} ${startY} Q ${cx} ${cy} ${endX} ${endY}`;
                        return; // 優先處理臨時連線
                    }

                    if (this.isMobile && event.pointerType === 'touch') {
                        const dx = Math.abs(event.clientX - this.lastPointerDown.x);
                        const dy = Math.abs(event.clientY - this.lastPointerDown.y);
                        const moveThreshold = 10;
                        if (dx > moveThreshold || dy > moveThreshold) {
                            clearTimeout(this.longPressTimer);
                        }
                    }

                    if (this.resizingNode) {
                        this.resizeChart(event);
                    }

                    if (this.draggingNodes.length > 0) {
                        const tx = this.boardOffset.x;
                        const ty = this.boardOffset.y;
                        const s = this.scale;
                        const svgX = (event.clientX - tx) / s;
                        const svgY = (event.clientY - ty) / s;

                        const dx = svgX - this.dragStart.x;
                        const dy = svgY - this.dragStart.y;
                        this.draggingNodes.forEach(n => {
                            n.x = n.initialX + dx;
                            n.y = n.initialY + dy;
                        });
                    } else if (this.selectionBox.active) {
                        // 獲取 SVG 元素
                        const svg = document.getElementById('mindmapSvg');
                        const point = svg.createSVGPoint();
                        point.x = event.clientX;
                        point.y = event.clientY;
                        // 將視窗坐標轉換為 SVG 坐標
                        const ctm = svg.getScreenCTM();
                        let svgCurrentX = (point.x - ctm.e) / ctm.a;
                        let svgCurrentY = (point.y - ctm.f) / ctm.d;
                        svgCurrentX = (svgCurrentX - this.boardOffset.x) / this.scale;
                        svgCurrentY = (svgCurrentY - this.boardOffset.y) / this.scale;
                        const startX = this.selectionBox.startX;
                        const startY = this.selectionBox.startY;
                        this.selectionBox.x = Math.min(startX, svgCurrentX);
                        this.selectionBox.y = Math.min(startY, svgCurrentY);
                        this.selectionBox.width = Math.abs(svgCurrentX - startX);
                        this.selectionBox.height = Math.abs(svgCurrentY - startY);
                    }
                    this.handleMouseMove(event);
                },


                // 結束托拽
                endDrag(event) {


                    // 鼠標左鍵釋放後的結束處理(放到下面就會出問題)
                    this.resizingNode = null;
                    if (event.button === 0) {
                        if (this.draggingNodes.length > 0) {
                            this.draggingNodes = [];
                        }
                        if (this.selectionBox.active) {
                            this.finishSelection();
                        }
                        this.isPanning = false;
                    }
                    this.handleMouseUp(event);


                    event.preventDefault();

                    // 避免重複執行：如果已經處理過此 pointerId，則跳過
                    if (this.processedEvents?.has(event.pointerId) && this.isMobile) {
                        return;
                    }
                    if (!this.processedEvents) {
                        this.processedEvents = new Set();
                    }
                    this.processedEvents.add(event.pointerId);
                    this.touchPoints.delete(event.pointerId); // 移除觸控點

                    // 只有在移動設備上模擬 click 和 dblclick
                    if (this.isMobile && event.pointerType === 'touch') {
                        const now = Date.now();
                        const clickThreshold = 300; // 點擊的最大時間間隔（毫秒）
                        const moveThreshold = 10; // 允許的最大移動距離（像素）
                        const doubleClickThreshold = 500; // 雙擊的最大時間間隔（毫秒）

                        const dx = Math.abs(event.clientX - this.lastPointerDown.x);
                        const dy = Math.abs(event.clientY - this.lastPointerDown.y);
                        const timeDiff = now - this.lastPointerDown.time;

                        if (dx < moveThreshold && dy < moveThreshold && timeDiff < clickThreshold) {
                            const simulatedEvent = { ...event, simulated: true };
                            const timeSinceLastClick = now - this.lastClick.time; // 計算與上一次點擊的時間差

                            if (event.target.id === 'mindmapSvg' ||
                                (event.target.tagName === 'rect' && event.target.getAttribute('fill') === 'url(#grid)')) {
                                if (timeSinceLastClick < doubleClickThreshold && this.lastClick.node === null) {
                                    this.addNodeAtContext(simulatedEvent);
                                    this.lastClick.time = 0; // 重置時間，避免連續觸發
                                    console.log("畫布雙擊");
                                } else {
                                    this.lastClick = { time: now, node: null }; // 更新上一次點擊資訊
                                    console.log("畫布單擊");
                                }
                            } else {
                                const nodeGroup = event.target.closest('g');
                                if (nodeGroup) {
                                    const nodeId = nodeGroup.getAttribute('data-id');
                                    const node = this.nodes.find(n => n.id === nodeId);
                                    if (node) {
                                        if (timeSinceLastClick < doubleClickThreshold && this.lastClick.node === node) {
                                            console.log("便利貼雙擊");
                                            this.editNode(node);
                                            this.lastClick.time = 0; // 重置時間
                                        } else {
                                            this.nodeClick(node);
                                            this.lastClick = { time: now, node: node }; // 更新上一次點擊資訊
                                            console.log("便利貼單擊");
                                        }
                                    }
                                }
                            }
                        }
                    }


                    // ========================

                    // 處理臨時連線結束
                    if (this.tempConnection.active) {
                        const svg = document.getElementById('mindmapSvg');
                        const point = svg.createSVGPoint();
                        point.x = event.clientX;
                        point.y = event.clientY;

                        const ctm = svg.getScreenCTM();
                        let svgX = (point.x - ctm.e) / ctm.a;
                        let svgY = (point.y - ctm.f) / ctm.d;

                        svgX = (svgX - this.boardOffset.x) / this.scale;
                        svgY = (svgY - this.boardOffset.y) / this.scale;

                        const targetNode = this.nodes.find(node => {
                            if (node === this.tempConnection.startNode) return false;
                            const width = node.type === 'chart' ? node.chartWidth : this.noteWidth;
                            const height = node.type === 'chart' ? node.chartHeight : this.noteHeight;
                            const rect = {
                                x: node.x - width / 2,
                                y: node.y - height / 2,
                                width: width,
                                height: height,
                            };
                            const isInRect = svgX >= rect.x && svgX <= rect.x + rect.width &&
                                svgY >= rect.y && svgY <= rect.y + rect.height;
                            return isInRect;
                        });

                        if (targetNode) {
                            if (this.willCauseLoop(this.tempConnection.startNode.id, targetNode.id)) {
                                Swal.fire({
                                    icon: 'warning',
                                    title: '無法連線',
                                    text: '此連線會導致循環，請檢查您的連線結構！',
                                });
                            } else if (this.tempConnection.startNode.connectionsOut.includes(targetNode.id)) {
                                Swal.fire({
                                    icon: 'warning',
                                    title: '無法連線',
                                    text: '重複連線了唷，請檢查您的連線結構！',
                                });
                            } else {
                                // 托拽連線用
                                this.pushConnections(this.tempConnection.startNode, targetNode);

                                this.calculateTotal();

                                if (targetNode.type === 'chart' && targetNode.connectionsIn.length >= 2) {
                                    this.renderChart(targetNode);
                                }
                            }
                        } else {

                            const newNode = this.addNode(svgX, svgY);

                            this.nodes.push(newNode);
                            // 建立連線（從基準便利貼到新便利貼）
                            this.pushConnections(this.tempConnection.startNode, newNode);

                            this.focusNodeText(newNode);

                            this.calculateTotal();
                        }

                        // 清理臨時連線
                        this.tempConnection.active = false;
                        this.tempConnection.startNode = null;
                        this.tempConnection.path = '';
                    }

                    // ========================


                    // 行動裝置的觸控結束後的狀態清理
                    if (event.pointerType === 'touch') {
                        clearTimeout(this.longPressTimer);
                        if (this.touchPoints.size < 2) {
                            this.isPanning = false;
                            this.lastDistance = null;
                        }
                    }
                    // 清理 processedEvents
                    if (event.type === 'pointerup') {
                        setTimeout(() => {
                            this.processedEvents.delete(event.pointerId);
                        }, 0);
                    }

                },

                // 結束拖曳或框選，若處於框選狀態則根據選取框更新各便利貼選取狀態
                // endDrag(event) {  // 注意：這裡需要加上 event 參數
                //     this.resizingNode = null; //圖表便利貼
                //     if (event.button === 0) {
                //         if (this.draggingNodes.length > 0) {
                //             this.draggingNodes = [];
                //         }
                //         if (this.selectionBox.active) {
                //             this.finishSelection();
                //         }
                //     }
                //     this.handleMouseUp(event);
                // },


                // 框選結束：檢查哪些便利貼的中心落在選取框內，並標記為 selected
                finishSelection() {
                    const vm = this;
                    const box = this.selectionBox;
                    this.nodes.forEach(n => {
                        if (n.x >= box.x && n.x <= box.x + box.width &&
                            n.y >= box.y && n.y <= box.y + box.height) {
                            n.selected = true;
                        }
                    });

                    // 選取連線
                    this.connections.forEach(conn => {
                        const fromNode = this.getNodeById(conn.from);
                        const toNode = this.getNodeById(conn.to);
                        if (!fromNode || !toNode) return;

                        // 獲取連線的起點和終點（目前是中心點，後續會改為邊緣）
                        const start = { x: fromNode.x, y: fromNode.y };
                        const end = { x: toNode.x, y: toNode.y };

                        // 簡單檢查：起點或終點是否在框選範圍內
                        const inRect = (x, y) => x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
                        const isStartInRect = inRect(start.x, start.y);
                        const isEndInRect = inRect(end.x, end.y);

                        // 如果起點或終點在框選範圍內，則選取該連線
                        if (isStartInRect || isEndInRect) {
                            conn.selected = true;
                        } else {
                            // 進階檢查：線段是否與框選矩形相交
                            const intersects = this.lineIntersectsRect(start, end, box);
                            if (intersects) {
                                conn.selected = true;
                            }
                        }
                    });

                    this.selectionBox.active = false;
                    this.selectionBox.width = 0;
                    this.selectionBox.height = 0;
                },

                // 取得線條本體選取
                lineIntersectsRect(start, end, rect) {
                    // 矩形的四條邊
                    const left = rect.x;
                    const right = rect.x + rect.width;
                    const top = rect.y;
                    const bottom = rect.y + rect.height;

                    // 線段的起點和終點
                    const x1 = start.x, y1 = start.y;
                    const x2 = end.x, y2 = end.y;

                    // 檢查線段是否與矩形的四條邊相交
                    const lineIntersectsLine = (x1, y1, x2, y2, x3, y3, x4, y4) => {
                        const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
                        if (denom === 0) return false; // 平行

                        const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
                        const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;

                        return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
                    };

                    // 檢查線段與矩形的四條邊
                    return (
                        lineIntersectsLine(x1, y1, x2, y2, left, top, right, top) || // 上邊
                        lineIntersectsLine(x1, y1, x2, y2, right, top, right, bottom) || // 右邊
                        lineIntersectsLine(x1, y1, x2, y2, right, bottom, left, bottom) || // 下邊
                        lineIntersectsLine(x1, y1, x2, y2, left, bottom, left, top) // 左邊
                    );
                },


                // 開始拖曳便利貼：如果該便利貼尚未選取，先清除其他選取；之後將所有已選取的便利貼作為拖曳群組
                startDrag(node, event) {
                    // event.preventDefault(); //有使用的話則無法點擊到選取，不使用的話則會無法連線(移動端有沒有用都無所謂)
                    if (this.isMobile) {
                        event.stopPropagation(); // 阻止事件冒泡，避免干擾
                    }
                    clearTimeout(this.longPressTimer);

                    this.lastPointerDown = {
                        time: Date.now(),
                        x: event.clientX,
                        y: event.clientY,
                        target: event.target
                    };

                    const targetTag = event.target.tagName.toLowerCase();
                    if (["textarea", "select"].includes(targetTag)) {
                        return;
                    }

                    // 確保初始值不會變成NAN
                    node.initialX = node.x || 0;
                    node.initialY = node.y || 0;

                    // 更新選取狀態
                    if (!node.selected) {
                        this.nodes.forEach(n => n.selected = false);
                        node.selected = true;
                    }


                    const tx = this.boardOffset.x;
                    const ty = this.boardOffset.y;
                    const s = this.scale;
                    const svgX = (event.clientX - tx) / s;
                    const svgY = (event.clientY - ty) / s;

                    this.dragStart = { x: svgX, y: svgY };
                    this.draggingNodes = this.nodes.filter(n => n.selected);
                    this.draggingNodes.forEach(n => {
                        n.startX = n.x;
                        n.startY = n.y;
                        n.userId = this.userId;
                        n.boardId = this.boardId;
                    });

                    // 綁定拖曳事件
                    document.addEventListener("mousemove", this.onDrag);
                    document.addEventListener("mouseup", this.stopDrag);

                },

                onDrag(event) {
                    if (!this.draggingNodes.length) return;

                    // 獲取當前平移和縮放值
                    const tx = this.boardOffset.x;
                    const ty = this.boardOffset.y;
                    const s = this.scale;
                    // 計算當前滑鼠在 SVG 座標系統中的位置
                    const svgX = (event.clientX - tx) / s;
                    const svgY = (event.clientY - ty) / s;
                    // 計算移動距離（SVG 座標系統）
                    const dx = svgX - this.dragStart.x;
                    const dy = svgY - this.dragStart.y;
                    // 更新每個節點的位置
                    this.draggingNodes.forEach(n => {
                        n.x = n.startX + dx;
                        n.y = n.startY + dy;
                    });
                },

                stopDrag() {
                    // 清理拖曳狀態
                    this.dragStart = null;
                    this.draggingNodes = [];
                    document.removeEventListener("mousemove", this.onDrag);
                    document.removeEventListener("mouseup", this.stopDrag);
                    //儲存狀態
                    this.saveState()
                },

                /* ================ 線條優化:圓圈拉線相關 ==================== */
                // AB點
                // 檢查是否為雙連情況
                isDoubleConnection(conn) {
                    const toNode = this.getNodeById(conn.to);
                    return toNode && toNode.connectionsIn.length === 2;
                },

                // 獲取 A/B 標籤
                getConnectionLabel(conn) {
                    const toNode = this.getNodeById(conn.to);
                    if (!toNode || toNode.connectionsIn.length !== 2) return '';
                    const index = toNode.connectionsIn.indexOf(conn.from);
                    return index === 0 ? 'A' : 'B';
                },

                // 調整圓圈位置（雙連時移出）
                getAdjustedArrowPosition(conn) {
                    const basePos = this.getArrowPosition(conn);
                    const toNode = this.getNodeById(conn.to);
                    if (!toNode) return basePos;

                    if (toNode.connectionsIn.length !== 2) {
                        return basePos;
                    }

                    const width = toNode.type === 'chart' ? toNode.chartWidth : this.noteWidth;
                    const height = toNode.type === 'chart' ? toNode.chartHeight : this.noteHeight;
                    const toRect = {
                        x: toNode.x - width / 2,
                        y: toNode.y - height / 2,
                        width: width,
                        height: height,
                    };

                    const left = toRect.x;
                    const right = toRect.x + toRect.width;
                    const top = toRect.y;
                    const bottom = toRect.y + toRect.height;

                    const minX = left + toRect.width * 0.2;
                    const maxX = left + toRect.width * 0.8;
                    const minY = top + toRect.height * 0.2;
                    const maxY = top + toRect.height * 0.8;

                    let adjustedX = basePos.x;
                    let adjustedY = basePos.y;

                    const offset = 5.33;

                    if (Math.abs(basePos.x - left) < 1) {
                        adjustedX -= offset;
                    } else if (Math.abs(basePos.x - right) < 1) {
                        adjustedX += offset;
                    }

                    if (Math.abs(basePos.y - top) < 1) {
                        adjustedY -= offset;
                    } else if (Math.abs(basePos.y - bottom) < 1) {
                        adjustedY += offset;
                    }

                    // 限制調整後的 X 和 Y 在 20% 到 80% 範圍內（僅用於非邊緣維度）
                    if (Math.abs(basePos.x - left) >= 1 && Math.abs(basePos.x - right) >= 1) {
                        adjustedX = Math.max(minX, Math.min(maxX, adjustedX));
                    }
                    if (Math.abs(basePos.y - top) >= 1 && Math.abs(basePos.y - bottom) >= 1) {
                        adjustedY = Math.max(minY, Math.min(maxY, adjustedY));
                    }

                    const result = { x: adjustedX, y: adjustedY };
                    // console.log('Adjusted arrow position:', result, 'for connection:', conn.connectionsId);
                    return result;
                },

                // 臨時線條
                startDragConnectionCircle(node, event) {
                    event.stopPropagation(); // 阻止事件冒泡
                    this.tempConnection.active = true;
                    this.tempConnection.startNode = node;

                    // 右邊圓圈的原始位置（未考慮縮放和位移）
                    const circleX = node.x - (node.type === 'chart' ? node.chartWidth : this.noteWidth) / 2 + 130;
                    const circleY = node.y - (node.type === 'chart' ? node.chartHeight : this.noteHeight) / 2 + 62;

                    // 考慮畫板縮放和位移
                    this.tempConnection.startX = circleX;
                    this.tempConnection.startY = circleY;

                    // document.addEventListener('mousemove', this.dragConnectionCircle);
                    // document.addEventListener('mouseup', this.endDragConnectionCircle, { once: true });
                },

                // 貌似被取消了
                dragConnectionCircle(event) {
                    if (!this.tempConnection.active) return;

                    const svg = document.getElementById('mindmapSvg');
                    const point = svg.createSVGPoint();
                    point.x = event.clientX;
                    point.y = event.clientY;

                    const ctm = svg.getScreenCTM();
                    let svgX = (point.x - ctm.e) / ctm.a;
                    let svgY = (point.y - ctm.f) / ctm.d;

                    // 考慮畫板縮放和位移
                    svgX = (svgX - this.boardOffset.x) / this.scale;
                    svgY = (svgY - this.boardOffset.y) / this.scale;

                    if (isNaN(svgX) || isNaN(svgY)) {
                        console.warn('Invalid SVG coordinates:', svgX, svgY);
                        return;
                    }

                    const startX = this.tempConnection.startX;
                    const startY = this.tempConnection.startY;
                    if (isNaN(startX) || isNaN(startY)) {
                        console.warn('Invalid start coordinates:', startX, startY);
                        return;
                    }

                    const endX = svgX;
                    const endY = svgY;
                    const mx = (startX + endX) / 2, my = (startY + endY) / 2;
                    const dx = endX - startX, dy = endY - startY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    let offset = 30;
                    if (len === 0) offset = 0;
                    const px = -dy / (len || 1), py = dx / (len || 1);
                    const cx = mx + px * offset, cy = my + py * offset;

                    this.tempConnection.path = `M ${startX} ${startY} Q ${cx} ${cy} ${endX} ${endY}`;
                },

                // 貌似被取消了
                endDragConnectionCircle(event) {
                    if (!this.tempConnection.active) return;

                    const svg = document.getElementById('mindmapSvg');
                    const point = svg.createSVGPoint();
                    point.x = event.clientX;
                    point.y = event.clientY;

                    const ctm = svg.getScreenCTM();
                    let svgX = (point.x - ctm.e) / ctm.a;
                    let svgY = (point.y - ctm.f) / ctm.d;

                    // 考慮畫板縮放和位移
                    svgX = (svgX - this.boardOffset.x) / this.scale;
                    svgY = (svgY - this.boardOffset.y) / this.scale;

                    const targetNode = this.nodes.find(node => {
                        if (node === this.tempConnection.startNode) return false;
                        const width = node.type === 'chart' ? node.chartWidth : this.noteWidth;
                        const height = node.type === 'chart' ? node.chartHeight : this.noteHeight;
                        const rect = {
                            x: node.x - width / 2,
                            y: node.y - height / 2,
                            width: width,
                            height: height,
                        };
                        const isInRect = svgX >= rect.x && svgX <= rect.x + rect.width &&
                            svgY >= rect.y && svgY <= rect.y + rect.height;
                        return isInRect;
                    });

                    if (targetNode) {
                        // 現有邏輯：拖曳到另一個節點，建立連線
                        if (this.willCauseLoop(this.tempConnection.startNode.id, targetNode.id)) {
                            Swal.fire({
                                icon: 'warning',
                                title: '無法連線',
                                text: '此連線會導致循環，請檢查您的連線結構！',
                            });
                        } else if (this.tempConnection.startNode.connectionsOut.includes(targetNode.id)) {
                            Swal.fire({
                                icon: 'warning',
                                title: '無法連線',
                                text: '重複連線了唷，請檢查您的連線結構！',
                            });
                        } else {
                            // 建立連線（從基準便利貼到新便利貼）
                            this.pushConnections(this.tempConnection.startNode, targetNode);

                            this.calculateTotal();

                            if (targetNode.type === 'chart' && targetNode.connectionsIn.length >= 2) {
                                this.renderChart(targetNode);
                            }
                        }
                    } else {
                        // 新功能：拖曳到空白位置，新增便利貼
                        const newNode = this.addNode(svgX, svgY)

                        // 將新便利貼添加到 nodes 數組
                        this.nodes.push(newNode);

                        // 建立與起始節點的連線
                        this.pushConnections(this.tempConnection.startNode, newNode);


                        this.focusNodeText(newNode);

                        // 重新計算總計（如果需要）
                        this.calculateTotal();
                    }

                    // 清理臨時連線
                    this.tempConnection.active = false;
                    this.tempConnection.startNode = null;
                    this.tempConnection.path = '';
                    document.removeEventListener('mousemove', this.dragConnectionCircle);
                },

                //換位計算
                getArrowPosition(conn) {
                    const toNode = this.getNodeById(conn.to);
                    if (!toNode) {
                        console.warn('toNode not found for connection:', conn);
                        return { x: 0, y: 0 };
                    }

                    const width = toNode.type === 'chart' ? toNode.chartWidth : this.noteWidth;
                    const height = toNode.type === 'chart' ? toNode.chartHeight : this.noteHeight;
                    const toRect = {
                        x: toNode.x - width / 2,
                        y: toNode.y - height / 2,
                        width: width,
                        height: height,
                    };

                    const fromNode = this.getNodeById(conn.from);
                    if (!fromNode) {
                        console.warn('fromNode not found for connection:', conn);
                        return { x: 0, y: 0 };
                    }

                    const endEdge = this.getEdgePoint(toNode, fromNode, toRect);

                    // 20% 到 80% 範圍（僅用於 Y 偏移）
                    const minY = toRect.y + toRect.height * 0.2;
                    const maxY = toRect.y + toRect.height * 0.8;

                    const yOffset = conn.yOffset || 0;
                    let y = endEdge.y + yOffset;
                    y = Math.max(minY, Math.min(maxY, y));

                    const result = { x: endEdge.x, y };
                    // console.log('Arrow position for connection:', conn.connectionsId, result);

                    if (isNaN(result.x) || isNaN(result.y)) {
                        console.warn('Invalid arrow position:', result, 'for connection:', conn);
                        return { x: toNode.x, y: toNode.y };
                    }

                    return result;
                },

                startDragArrow(conn, event) {
                    this.draggingArrow = conn;
                    this.dragArrowStartY = event.offsetY;
                    document.addEventListener('mousemove', this.dragArrow);
                    document.addEventListener('mouseup', this.endDragArrow, { once: true });
                },

                dragArrow(event) {
                    if (!this.draggingArrow) return;

                    const dy = (event.offsetY - this.dragArrowStartY) / this.scale; // 考慮縮放
                    this.draggingArrow.yOffset = (this.draggingArrow.yOffset || 0) + dy;
                    this.dragArrowStartY = event.offsetY;
                },

                endDragArrow() {
                    if (this.draggingArrow) {
                        const toNode = this.getNodeById(this.draggingArrow.to);
                        if (toNode) {
                            // 根據所有連入線條的 Y 座標重新排序 connectionsIn
                            const incomingConnections = this.connections.filter(c => c.to === toNode.id);
                            incomingConnections.sort((a, b) => {
                                const posA = this.getArrowPosition(a).y;
                                const posB = this.getArrowPosition(b).y;
                                return posA - posB;
                            });

                            // 更新 connectionsIn 順序
                            toNode.connectionsIn = incomingConnections.map(c => c.from);
                            this.calculateTotal(); // 重新計算總額
                        }
                    }
                    this.draggingArrow = null;
                    document.removeEventListener('mousemove', this.dragArrow);
                },

                changeLineColor(color) {
                    this.connections.forEach(conn => {
                        if (conn.selected) {
                            conn.color = color;
                            conn.selected = false;

                        }
                    })
                    this.nodes.forEach(n => {
                        if (n.selected) {
                            n.selected = false;
                        }
                    })
                },

                changeLineType(type) {

                    this.connections.forEach(conn => {
                        if (conn.selected) {
                            conn.type = this.getDashArray(type);
                            conn.selected = false;

                        }
                    });
                    this.nodes.forEach(n => {
                        if (n.selected) {
                            n.selected = false;
                        }
                    });
                },

                getDashArray(type) {
                    switch (type) {
                        case 'solid': return 'none';
                        case 'dashed': return '12,6'; // 中空線
                        case 'dotted': return '2,2'; // 點線
                        default: return 'none';
                    }
                },

                /* ================ 一般便利貼 ==================== */

                showFullText(node) {
                    Swal.fire({
                        title: '便利貼內容',
                        html: `<pre style="text-align: left; white-space: pre-wrap; max-height: 400px; overflow-y: auto;">${node.label}</pre>`,
                        width: '600px',
                        confirmButtonText: '關閉',
                    });
                },

                /* ================ 圖表便利貼 ==================== */
                //側欄新增圖表便利貼
                addChartNodeRight(event) {
                    this.addChartNode(190, 140, event);
                },

                //右鍵新增便利貼圖表
                addChartNodeAtContext(event) {
                    this.addChartNode(0, 0, event);
                },

                /* 圖表便利貼相關方法 */
                addChartNode(addX, addY, event) {
                    const vm = this;
                    const svgElement = document.getElementById('mindmapSvg');
                    const rect = svgElement.getBoundingClientRect();
                    const x = event ? (event.clientX - rect.left - this.boardOffset.x) / this.scale : this.center.x;
                    const y = event ? (event.clientY - rect.top - this.boardOffset.y) / this.scale : this.center.y;
                    const newNode = {
                        id: `chart-${Date.now()}`,
                        type: 'chart',
                        x: x + addX,
                        y: y + addY,
                        chartWidth: 400,
                        chartHeight: 240,
                        chartType: 'bar', // 預設為柱狀圖
                        color: '#fdfdfd',
                        colorTop: '#dddddd',
                        selected: false,
                        connectionsOut: [],
                        connectionsIn: [],
                        userId: vm.userId,
                        boardId: vm.boardId,

                    };
                    this.nodes.push(newNode);
                    this.contextMenu.visible = false;
                    this.$nextTick(() => {
                        setTimeout(() => this.renderChart(newNode), 50); // 延遲渲染以確保 DOM 準備好
                    });
                    this.saveState();
                },

                renderChart(node) {
                    const vm = this;
                    const container = document.querySelector(`#${node.id}`);
                    if (!container) {
                        console.error('Chart container not found for ID:', node.id);
                        return;
                    }
                    // 確保銷毀舊實例
                    if (this.chartInstances[node.id]) {
                        this.chartInstances[node.id].destroy();
                        delete this.chartInstances[node.id];
                    }

                    let categories = ['範例1', '範例2', '範例3']; // 預設值
                    let data = [10, 20, 30]; // 預設值
                    if (node.connectionsIn.length >= 2) {
                        const firstNode = this.getNodeById(node.connectionsIn[0]);
                        const secondNode = this.getNodeById(node.connectionsIn[1]);
                        if (firstNode) {
                            categories = vm.regularSplitString(firstNode) || categories;
                        }
                        if (secondNode) {
                            const matches = vm.regularSplitNumbers(secondNode);
                            data = matches ? matches.map(num => parseFloat(num)) : data; // 如果 matches 為 null，使用預設值
                        }
                    }

                    if (node.chartType == 'bar' || node.chartType == 'line' || node.chartType == 'area' || node.chartType == 'radar') {

                        const options = {
                            chart: {
                                type: node.chartType || 'pie',
                                height: node.chartHeight - 40,
                                width: node.chartWidth - 20,
                            },
                            series: [{
                                name: '數據',
                                data: data,
                            }],
                            xaxis: {
                                categories: categories,
                            },
                            plotOptions: {
                                bar: {
                                    borderRadius: 4,
                                    borderRadiusApplication: 'end',
                                    horizontal: true,
                                }
                            },
                            colors: ['#ff6384'],
                            dataLabels: {
                                enabled: true,
                                style: {
                                    colors: ['#dddddd']
                                }
                            }
                        };
                        this.chartInstances[node.id] = new ApexCharts(container, options);
                        this.chartInstances[node.id].render();
                    } else if (node.chartType == 'pie' || node.chartType == 'polarArea' || node.chartType == 'donut' || node.chartType == 'radialBar') {

                        const options = {
                            chart: {
                                type: node.chartType || 'pie',
                                height: node.chartHeight - 40,
                                width: node.chartWidth - 20,
                            },
                            series: data,
                            labels: categories,
                            colors: ['#ff6384'],
                            dataLabels: {
                                enabled: true,
                                style: {
                                    colors: ['#dddddd']
                                }
                            }
                        };
                        this.chartInstances[node.id] = new ApexCharts(container, options);
                        this.chartInstances[node.id].render();
                    } else {

                        // 時間類型
                        const firstNode = this.getNodeById(node.connectionsIn[0]);
                        const secondNode = this.getNodeById(node.connectionsIn[1]);

                        const labels = firstNode ? vm.regularSplitNumbers(firstNode) : [];
                        const dateStrings = secondNode ? vm.regularSplitTime(secondNode) : [];

                        const timelineData = [];
                        for (let i = 0; i < labels.length; i++) {
                            const startStr = dateStrings[i * 2];
                            const endStr = dateStrings[i * 2 + 1];
                            if (!startStr || !endStr) continue;
                            const start = new Date(vm.convertToISOWithMoment(startStr)).getTime();
                            const end = new Date(vm.convertToISOWithMoment(endStr)).getTime();
                            if (start >= end) continue;
                            timelineData.push({
                                x: labels[i],
                                y: [start, end]
                            });
                        }

                        const options = {
                            series: [{
                                data: timelineData
                            }],
                            chart: {
                                height: 350,
                                type: 'rangeBar'
                            },
                            dataLabels: {
                                enabled: true,
                                formatter: function (val) {
                                    var a = moment(val[0]);
                                    var b = moment(val[1]);
                                    var diff = b.diff(a, 'days');
                                    return diff + (diff > 1 ? ' days' : ' day');
                                }
                            },
                            plotOptions: {
                                bar: {
                                    horizontal: true,
                                }
                            },
                            xaxis: {
                                type: 'datetime',
                            },
                        };
                        this.chartInstances[node.id] = new ApexCharts(container, options);
                        this.chartInstances[node.id].render();
                    }
                },
                // time
                regularSplitTime(node) {
                    if (!node || !node.label) return [];

                    // 正則拆出日期 + 時間字串（格式：yyyy/mm/dd hh:mm:ss AM/PM）
                    const regex = /(\d{4}\/\d{1,2}\/\d{1,2}\s+\d{1,2}:\d{2}:\d{2}\s+[AP]M)/g;
                    return node.label.match(regex) || [];
                },
                // 換算時間(我自己要用的)
                convertToISOWithMoment(dateStr) {
                    return moment(dateStr, "YYYY/MM/DD hh:mm:ss A").format("YYYY-MM-DDTHH:mm:ss");
                },
                /** 
                 * 正則:分割字串
                 * 按空格分割，並濾除空字串
                 * */
                regularSplitString(node) {
                    // 確保 node.label 是字符串，若不是則返回預設值
                    const label = typeof node.label === 'string' ? node.label : '';
                    return label.split(/\s+/).filter(Boolean);
                },
                // 正則:分割數字
                regularSplitNumbers(node) {
                    // 確保 node.label 是字符串，若不是則返回 null
                    const label = typeof node.label === 'string' ? node.label : '';
                    return label.match(/-?\d*\.?\d+/g); // 返回匹配的數字數組，或 null
                },

                refreshChartsConnectedTo(node) {
                    this.nodes.forEach(chartNode => {
                        if (chartNode.type === 'chart' && chartNode.connectionsIn.includes(node.id)) {
                            this.renderChart(chartNode);
                        }
                    });
                },

                startResize(node, event) {
                    this.resizingNode = node;
                    this.resizeStartX = event.clientX;
                    this.resizeStartY = event.clientY;
                    document.addEventListener('mousemove', this.resizeChart);
                    document.addEventListener('mouseup', this.stopResize);
                },

                // 調整便利貼大小
                resizeChart(event) {
                    if (!this.resizingNode) return;
                    const dx = event.clientX - this.resizeStartX;
                    const dy = event.clientY - this.resizeStartY;
                    this.resizingNode.chartWidth = Math.max(300, this.resizingNode.chartWidth + dx);
                    this.resizingNode.chartHeight = Math.max(200, this.resizingNode.chartHeight + dy);
                    this.resizeStartX = event.clientX;
                    this.resizeStartY = event.clientY;
                    this.$nextTick(() => {
                        // setTimeout(() => this.renderChart(this.resizingNode), 50);
                        this.renderChart(this.resizingNode);
                    });
                },

                stopResize() {
                    this.resizingNode = null;
                    document.removeEventListener('mousemove', this.resizeChart);
                    document.removeEventListener('mouseup', this.stopResize);
                    this.saveState();
                },


                /* ================ 圖表便利貼 ==================== */




                /* ===== 狀態快照 系統，記錄每次操作的變更，然後可以回溯或前進。 ===== */
                saveState() {
                    // 深拷貝 nodes 和 connections
                    const state = {
                        nodes: JSON.parse(JSON.stringify(this.nodes)),
                        connections: JSON.parse(JSON.stringify(this.connections))
                    };
                    // 移除指針之後的歷史（若有），並加入新狀態
                    this.history = this.history.slice(0, this.currentIndex + 1);
                    if (this.history.length >= 60) { // 限制最多 60 步
                        this.history.shift();
                        this.currentIndex--;
                    }
                    this.history.push(state);
                    this.currentIndex++;
                },
                undo() {
                    if (this.currentIndex > 0) { // 確保有前一個狀態可回退
                        this.currentIndex--;
                        const state = this.history[this.currentIndex];
                        this.nodes = state.nodes;
                        this.connections = state.connections;
                    }
                },
                redo() {
                    if (this.currentIndex < this.history.length - 1) { // 確保有下一個狀態可前進
                        this.currentIndex++;
                        const state = this.history[this.currentIndex];
                        this.nodes = state.nodes;
                        this.connections = state.connections;
                    }
                },

                /* ========便利貼文字部分========= */

                // formatText: 自動換行並截斷超過指定字數（30字）的部分
                formatText(text) {
                    const maxChars = 30;
                    if (!text) return '';
                    return text.length > maxChars ? text.substring(0, maxChars) + "....." : text;
                },

                // 雙擊文字進入編輯模式
                editNode(node) {

                    if (node.type !== 'chart' && node.connectionsIn.length <= 1) {
                        this.focusNodeText(node);
                    }
                },

                //關注便利貼(進入新便利貼的編輯模式)
                focusNodeText(newNode) {
                    const node = this.nodes.find(n => n.id === newNode.id);
                    node.selected = true;
                    node.editing = true;
                    this.$nextTick(() => {
                        const textarea = document.querySelector(`#app textarea`);
                        if (textarea) {
                            textarea.focus();
                            textarea.select();
                        }
                    });
                },

                edittodo() {
                    // this.cacheTitle = title;
                    this.editName = !this.editName;
                    this.$nextTick(() => {
                        const textarea = document.querySelector(`#app input`);
                        if (textarea) {
                            textarea.focus();
                            textarea.select();
                        }
                    });

                },

                // computeTotal: 提取所有數字（含負號）並加總後存入 node.total
                computeTotal(node) {
                    const matches = node.label.match(/-?\d*\.?\d+/g);
                    let total = 0;
                    if (matches) {
                        matches.forEach(numStr => {
                            total += parseFloat(numStr);
                        });
                    }
                    node.total = total;
                    node.count = total;
                    return total;
                },

                // 結束編輯
                finishEdit(node) {
                    const vm = this;

                    node.editing = false;
                    const newTotal = this.computeTotal(node);
                    node.total = newTotal;
                    node.count = newTotal;

                    this.calculateTotal()
                    this.refreshChartsConnectedTo(node); // 編輯完成後刷新相關圖表
                },

                /* ========便利貼文字部分========= */
                updateTotal(node) {
                    let values = 0;

                    if (node.type === 'chart') return;

                    if (node.connectionsIn.length === 1) {
                        const a = this.getNodeById(node.connectionsIn[0]).total || 0;
                        const b = node.count || 0;
                        values = a + b;
                        node.label = node.label; // 保留原有 label
                        values = Math.round(values * 100) / 100;
                        node.total = values;
                    } else if (node.connectionsIn.length === 2) {
                        const a = this.getNodeById(node.connectionsIn[0]).total || 0;
                        const b = this.getNodeById(node.connectionsIn[1]).total || 0;
                        switch (node.operation) {
                            case "sum": values = a + b; break;
                            case "subtractAB": values = a - b; break;
                            case "multiply": values = a * b; break;
                            case "divideAB": values = b !== 0 ? a / b : 0; break;
                            case "modulusAB": values = b !== 0 ? a % b : 0; break;
                            default: values = 0;
                        }
                        values = Math.round(values * 100) / 100;
                        node.label = values;
                        node.total = values;
                    } else if (node.connectionsIn.length >= 3) {
                        values = 0;
                        for (let i = 0; i < node.connectionsIn.length; i++) {
                            const a = this.getNodeById(node.connectionsIn[i]).total || 0;
                            values += a;
                        }
                        values = Math.round(values * 100) / 100;
                        node.label = values;
                        node.total = values;
                    }

                    return Math.round(values * 100) / 100;;
                },


                // 點擊便利貼：若處於連線模式則建立連線；否則若按住 Shift 則切換選取狀態
                nodeClick(node, event) {
                    const vm = this;
                    if (vm.connectionStartNode && vm.connectionStartNode.id !== node.id) {
                        // 檢查是否會形成循環
                        if (vm.willCauseLoop(vm.connectionStartNode.id, node.id)) {
                            Swal.fire({
                                icon: 'warning',
                                title: '無法連線',
                                text: '此連線會導致循環，請檢查您的連線結構！',
                            });
                            vm.connectionStartNode = null;
                            return;
                        }
                        // 檢查是否重複連線
                        vm.connectionStartNode.connectionsOut.forEach(conn => {
                            if (conn == node.id) {
                                Swal.fire({
                                    icon: 'warning',
                                    title: '無法連線',
                                    text: '重複連線了唷，請檢查您的連線結構！',
                                });
                                vm.connectionStartNode = null;
                                return;
                            }
                        })

                        // 新增連線
                        vm.pushConnections(vm.connectionStartNode, node);


                        vm.connectionStartNode.connectionsOut.push(node.id);
                        node.connectionsIn.push(vm.connectionStartNode.id);
                        vm.connectionStartNode = null;

                        vm.calculateTotal();

                        // 新增連線後檢查並刷新圖表
                        if (node.type === 'chart' && node.connectionsIn.length >= 2) {
                            vm.renderChart(node);
                        }
                    } else {
                        if (vm.isMobile) {
                            node.selected = !node.selected;
                        }
                    }
                },

                willCauseLoop(fromId, toId) {
                    const visited = new Set();
                    const recStack = new Set();

                    const dfs = (currentId, isNewConnection = false) => {
                        if (recStack.has(currentId)) return true; // 發現循環
                        if (visited.has(currentId)) return false;

                        visited.add(currentId);
                        recStack.add(currentId);

                        const node = this.getNodeById(currentId);
                        let nextNodes = [...node.connectionsOut];

                        // 如果是起始節點，模擬新連線
                        if (currentId === fromId && !isNewConnection) {
                            nextNodes.push(toId);
                        }

                        for (const nextId of nextNodes) {
                            if (dfs(nextId, currentId === fromId)) {
                                return true;
                            }
                        }

                        recStack.delete(currentId);
                        return false;
                    };

                    // console.log('Checking loop from', fromId, 'to', toId);
                    return dfs(fromId);
                },

                calculateTotal() {
                    // 重置所有節點的 total，避免舊值影響
                    this.nodes.forEach(item => {
                        if (item.type !== 'chart') {
                            item.total = item.count || 0;
                        }
                    });

                    // 使用訪問標記避免循環
                    const visited = new Set();
                    const tempMark = new Set();

                    const visit = (node) => {
                        if (tempMark.has(node.id)) return; // 跳過循環
                        if (visited.has(node.id)) return;

                        tempMark.add(node.id);

                        node.connectionsIn.forEach(inId => {
                            const inNode = this.getNodeById(inId);
                            visit(inNode);
                        });

                        tempMark.delete(node.id);
                        visited.add(node.id);

                        this.updateTotal(node);
                    };

                    this.nodes.forEach(node => visit(node));
                    this.saveState();
                },

                // 空白處右鍵選單
                handleSvgContextMenu(event) {
                    const node = this.nodes.find(n => n.selected === true);
                    if (event.button === 2) {
                        this.contextMenu.visible = true;
                        this.contextMenu.x = event.clientX;
                        this.contextMenu.y = event.clientY;
                        this.contextMenu.type = 'blank';
                        this.contextMenu.node = node ? node : null;
                        this.contextMenu.connection = null;
                        this.connectionStartNode = null;
                    }
                },


                hideContextMenu() {
                    this.contextMenu.visible = false;
                },

                // 在空白右鍵選單中點「新增節點」，根據滑鼠位置新增便利貼
                addNodeAtContext() {
                    const svgElement = document.getElementById('mindmapSvg');
                    const rect = svgElement.getBoundingClientRect();
                    const x = (event.clientX - rect.left - this.boardOffset.x) / this.scale;
                    const y = (event.clientY - rect.top - this.boardOffset.y) / this.scale;

                    const newNode = this.addNode(x, y)
                    this.contextMenu.visible = false;
                    //進入新便利貼的編輯模式
                    this.focusNodeText(newNode);
                },
                //側欄新增便利貼
                addNodeAtRight() {
                    const svgElement = document.getElementById('mindmapSvg');
                    const rect = svgElement.getBoundingClientRect();
                    const x = (event.clientX - rect.left - this.boardOffset.x) / this.scale;
                    const y = (event.clientY - rect.top - this.boardOffset.y) / this.scale;

                    const newNode = this.addNode(x + 150, y + 0)
                    this.contextMenu.visible = false;
                    //進入新便利貼的編輯模式
                    this.focusNodeText(newNode);
                },
                // 按下 Tab 鍵時，在選取的一般便利貼右邊新增一個便利貼並連線
                addNodeOnTab() {
                    const vm = this;
                    // 獲取所有選取的便利貼
                    const selectedNodes = this.nodes.filter(n => n.selected);
                    // 如果沒有選取的便利貼，則不執行
                    if (selectedNodes.length === 0) {
                        return;
                    }
                    // 找到第一個一般便利貼（type: 'general'）
                    const baseNode = selectedNodes.find(n => n.type === 'general');
                    if (!baseNode) {
                        return; // 如果選取的便利貼中沒有一般便利貼，則不執行
                    }
                    const newNode = this.addNode(baseNode.x + 200, baseNode.y + 0)
                    // 將新便利貼添加到 nodes 數組
                    this.nodes.push(newNode);

                    // 建立連線（從基準便利貼到新便利貼）
                    this.pushConnections(baseNode, newNode);

                    baseNode.selected = false;

                    // 重新計算總計（如果需要）
                    this.calculateTotal();

                    // 進入新便利貼的編輯模式
                    this.focusNodeText(newNode);
                },

                // 新增便利貼
                addNode(addX, addY) {
                    const vm = this;
                    const newNode = {
                        id: Math.random().toString(36).substring(2, 12), //取隨機8字元
                        label: 'New Node',
                        type: 'general',
                        x: addX,
                        y: addY,
                        color: '#FFF8CA',
                        colorTop: '#FFF4B2',
                        editing: false,
                        selected: true,
                        operation: "sum",  // 預設值
                        connectionsOut: [],
                        connectionsIn: [],
                        connections: [],
                        total: 0,
                        count: 0,
                        userId: vm.userId,
                        boardId: vm.boardId,
                    };
                    this.nodes.push(newNode);
                    return newNode;
                },

                // 建立連線（從基準便利貼到新便利貼）
                pushConnections(fromNode, toNode) {
                    this.connections.push({
                        from: fromNode.id,
                        to: toNode.id,
                        selected: true,
                        userId: this.userId,
                        boardId: this.boardId,
                        color: '#FFB53E',
                        type: '12,6',
                        connectionsId: Math.random().toString(36).substring(2, 12),
                    });

                    // 更新連線關係
                    fromNode.connectionsOut.push(toNode.id);
                    toNode.connectionsIn.push(fromNode.id);
                },

                // ============== 連線相關 ===============
                // 右鍵選單中「開始連線」
                startConnection(node) {
                    this.connectionStartNode = node;
                    this.contextMenu.visible = false;
                    // alert('請點擊另一個便利貼以建立連線');
                },


                handleKeyDown(event) {
                    // Enter 按鍵：關閉編輯模式 加SHIFT則換行
                    if (event.key === 'Enter' && event.shiftKey) {
                        console.log("換行")

                        return;
                    }

                    if (event.key === 'Enter') {
                        event.preventDefault();
                        const editingNode = this.nodes.find(n => n.editing);
                        if (editingNode) {
                            this.finishEdit(editingNode);
                        }

                    }

                    // Tab 按鍵：新增便利貼並連線
                    else if (event.key === 'Tab') {
                        event.preventDefault(); // 防止 Tab 鍵切換焦點
                        if (this.nodes.some(n => n.editing)) {
                            this.nodes.find(n => n.editing).editing = false
                        } else {
                            this.addNodeOnTab();
                        }
                    }

                    // DELETE 按鍵：刪除所有已選取的便利貼與連線
                    if (event.key === 'Delete') {

                        this.deleteConnection()
                        // 記錄所有被選取的節點 ID
                        const deletedIds = this.nodes.filter(node => node.selected).map(node => node.id);

                        // 刪除所有選取的節點
                        this.nodes = this.nodes.filter(node => !node.selected);

                        // 刪除相關連線
                        this.connections = this.connections.filter(conn => {
                            // 若連線兩端皆存在且未被選取則保留
                            const fromExists = this.nodes.some(n => n.id === conn.from);
                            const toExists = this.nodes.some(n => n.id === conn.to);
                            return fromExists && toExists && !conn.selected;
                        });


                        // 更新剩餘節點的 connectionsIn
                        this.deleteForEachNodes(deletedIds);
                        // 重新計算
                        this.calculateTotal()
                        //儲存狀態
                        this.saveState()
                    }


                    if (event.ctrlKey && event.key === 'z' || event.key === 'Z') {
                        if (event.shiftKey) {
                            console.log("CTRL+SHIFT+Z 重做")
                            this.redo(); // CTRL+SHIFT+Z 重做
                        } else {
                            console.log("CTRL+Z 撤銷")
                            this.undo(); // CTRL+Z 撤銷
                        }
                    };


                },

                deleteBtn() {
                    // 記錄所有被選取的節點 ID
                    const deletedIds = this.nodes.filter(node => node.selected).map(node => node.id);

                    // 刪除所有選取的節點
                    this.nodes = this.nodes.filter(node => !node.selected);

                    // 刪除相關連線
                    this.connections = this.connections.filter(conn => {
                        // 若連線兩端皆存在且未被選取則保留
                        const fromExists = this.nodes.some(n => n.id === conn.from);
                        const toExists = this.nodes.some(n => n.id === conn.to);
                        return fromExists && toExists && !conn.selected;
                    });

                    // 更新剩餘節點的 connectionsIn
                    this.deleteForEachNodes(deletedIds);
                    // 重新計算
                    this.calculateTotal()
                    //儲存狀態
                    this.saveState()
                },

                deleteNode(node) {
                    if (node.type === 'chart' && this.chartInstances[node.id]) {
                        this.chartInstances[node.id].destroy();
                        delete this.chartInstances[node.id];
                    }
                    // 刪除該節點
                    this.nodes = this.nodes.filter(n => n.id !== node.id);
                    // 刪除所有與該節點相關的連線
                    this.connections = this.connections.filter(conn => conn.from !== node.id && conn.to !== node.id);

                    this.deleteForEachNodes([node.id]);
                    // 隱藏右鍵選單
                    this.contextMenu.visible = false;
                    // 重新計算
                    this.calculateTotal()
                    //儲存狀態
                    this.saveState()
                },

                //傳入陣列ID後查找
                deleteForEachNodes(deletedIds) {
                    // 更新所有節點，移除 connectionsIn 中包含在 deletedIds 中的 ID
                    this.nodes.forEach(n => {
                        n.connectionsIn = n.connectionsIn.filter(id => !deletedIds.includes(id));
                    });
                },
                // 傳入單一ID後查找
                deleteForEachNode(node) {
                    // 更新所有節點，移除 connectionsIn 中包含該節點 ID 的項目
                    this.nodes.forEach(n => {
                        n.connectionsIn = n.connectionsIn.filter(id => id !== node.id);
                    });
                },
                // 刪除連線
                deleteConnection() {
                    // 獲取所有選取的連線
                    const selectedConnections = this.connections.filter(conn => conn.selected);
                    if (selectedConnections.length === 0) {
                        this.contextMenu.visible = false;
                        return;
                    }

                    // 刪除選取的連線並更新 connectionsIn 和 connectionsOut
                    selectedConnections.forEach(conn => {
                        const fromNode = this.getNodeById(conn.from);
                        const toNode = this.getNodeById(conn.to);

                        if (fromNode) {
                            fromNode.connectionsOut = fromNode.connectionsOut.filter(id => id !== conn.to);
                        }
                        if (toNode) {
                            toNode.connectionsIn = toNode.connectionsIn.filter(id => id !== conn.from);
                        }
                    });

                    // 從 connections 中移除選取的連線
                    this.connections = this.connections.filter(conn => !conn.selected);

                    // 關閉右鍵選單
                    this.contextMenu.visible = false;

                    // 重新計算總額
                    this.calculateTotal();

                    // 儲存狀態
                    this.saveState();
                },
                // 點擊曲線時切換選取狀態（顏色從紅變藍）
                toggleConnectionSelection(conn, event) {
                    if (event.button === 0) { // 左鍵點擊
                        conn.selected = !conn.selected;
                        // 取消其他連線的選取（如果需要單選）
                        if (!event.shiftKey) {
                            this.connections.forEach(c => {
                                if (c !== conn) c.selected = false;
                            });
                        }
                    }
                },
                // ============== 連線相關 ===============


                // 右鍵選單中更換便利貼顏色，將 node.color 改為指定顏色
                changeNodeColor(nodeType, color, colorTop) {
                    this.nodes.forEach(n => {
                        if (n.selected) {
                            if (n.type == nodeType) {
                                // 換色
                                n.color = color;
                                n.colorTop = colorTop;
                            }
                            n.selected = false;
                        }
                    })
                    this.connections.forEach(conn => {
                        if (conn.selected) {
                            conn.selected = false;
                        }
                    })

                },
                // 預留:分享功能
                sendBoard() {

                },

                // 預留:共用功能
                shareBoard() {

                },



                // 計算邊緣交點
                getEdgePoint(fromNode, toNode, rect) {
                    const x1 = fromNode.x, y1 = fromNode.y;
                    const x2 = toNode.x, y2 = toNode.y;

                    // 計算方向向量和角度
                    const dx = x2 - x1, dy = y2 - y1;
                    const angle = Math.atan2(dy, dx);

                    // 便利貼邊界
                    const left = rect.x;
                    const right = rect.x + rect.width;
                    const top = rect.y;
                    const bottom = rect.y + rect.height;

                    // 20% 到 80% 範圍
                    const minX = left + rect.width * 0.2;
                    const maxX = left + rect.width * 0.8;
                    const minY = top + rect.height * 0.2;
                    const maxY = top + rect.height * 0.8;

                    // 根據角度選擇邊緣點
                    let edgeX, edgeY;
                    const angleThreshold = Math.PI / 4; // 45 度

                    if (Math.abs(angle) < angleThreshold || Math.abs(angle) > Math.PI - angleThreshold) {
                        // 接近水平方向（左右）
                        if (dx > 0) {
                            // 向右（fromNode 在 toNode 左邊）
                            edgeX = right;
                            edgeY = y1 + (right - x1) * dy / (dx || 1);
                            // 只限制 Y 在 20% 到 80% 範圍內
                            edgeY = Math.max(minY, Math.min(maxY, edgeY));
                        } else {
                            // 向左（fromNode 在 toNode 右邊）
                            edgeX = left;
                            edgeY = y1 + (left - x1) * dy / (dx || 1);
                            // 只限制 Y 在 20% 到 80% 範圍內
                            edgeY = Math.max(minY, Math.min(maxY, edgeY));
                        }
                    } else {
                        // 接近垂直方向（上下）
                        if (dy > 0) {
                            // 向下（fromNode 在 toNode 上方）
                            edgeY = bottom;
                            edgeX = x1 + (bottom - y1) * dx / (dy || 1);
                            // 只限制 X 在 20% 到 80% 範圍內
                            edgeX = Math.max(minX, Math.min(maxX, edgeX));
                        } else {
                            // 向上（fromNode 在 toNode 下方）
                            edgeY = top;
                            edgeX = x1 + (top - y1) * dx / (dy || 1);
                            // 只限制 X 在 20% 到 80% 範圍內
                            edgeX = Math.max(minX, Math.min(maxX, edgeX));
                        }
                    }

                    const result = { x: edgeX, y: edgeY };
                    return result;
                },


                /* ================ 後端 ==================== */

                pageNodesUpload() {
                    const vm = this;
                    vm.nodes_upload();
                    // vm.connections_upload();
                    // vm.board_upload();

                    location.href = "StickyCalc_board.html";
                },

                goIndex() {
                    const vm = this;
                    vm.nodes_upload();
                    // vm.connections_upload();
                    // vm.board_upload();

                    location.href = "index.html";
                },

                //電腦端儲存邏輯
                handleBeforeUnload(event) {
                    // 調用儲存方法
                    this.nodesUpload();

                    // 可選：顯示確認提示（如果需要用戶確認）
                    // event.preventDefault();
                    // event.returnValue = '您有未儲存的變更，確定要離開嗎？';
                },

                handlePageHide(event) {
                    // 移動端儲存邏輯
                    this.nodesUpload();

                    // 如果頁面進入 BFCache，設置 persisted 屬性
                    if (event.persisted) {
                        console.log('Page is being cached (BFCache)');
                    }
                },

                handleVisibilityChange() {
                    // 當頁面隱藏時儲存
                    if (document.visibilityState === 'hidden') {
                        this.nodesUpload();
                    }
                },



                nodesUpload() {
                    const vm = this;
                    vm.nodes_upload();

                    // 清除計時器
                    if (this.uploadTimer) {
                        clearTimeout(this.uploadTimer);
                        this.uploadTimer = null;
                        this.isAutoUpload = true;
                    }
                },

                nodes_upload() {
                    const vm = this;
                    if (vm.userId != "") {
                        // 構建傳遞的資料物件
                        var JSONdata = {
                            nodes: vm.nodes,       // 便利貼陣列
                            userId: vm.userId,     // 用戶 ID
                            boardId: vm.boardId    // 白板 ID
                        };

                        $.ajax({
                            type: "POST",
                            url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=nodes_upload",
                            data: JSON.stringify(JSONdata),
                            dataType: "json",
                            success: function (data) {
                                console.log("便利貼" + data.state + data.message);
                            },
                            error: function () {
                                Swal.fire({
                                    title: "API串接錯誤",
                                    text: "保存便利貼失敗 請聯繫作者",
                                    icon: "error"
                                });
                            }
                        });
                        vm.connections_upload();
                        vm.board_upload();
                    }
                },

                connections_upload() {
                    const vm = this;
                    var JSONdata01 = [];
                    //傳遞至後端API執行上傳行為
                    // JSONdata01 = vm.connections;
                    if (vm.connections.length >= 1) {
                        for (i = 0; i < vm.connections.length; i++) {
                            JSONdata01.push({
                                boardId: vm.boardId,
                                userId: vm.userId,
                                from: vm.connections[i].from,
                                to: vm.connections[i].to,
                                color: vm.connections[i].color,
                                type: vm.connections[i].type,
                                connectionsId: vm.connections[i].connectionsId
                            })
                        }
                    }
                    // 構建傳遞的資料物件
                    var JSONdata = {
                        connections: JSONdata01,       // 便利貼陣列
                        userId: vm.userId,     // 用戶 ID
                        boardId: vm.boardId    // 白板 ID
                    };

                    $.ajax({
                        type: "POST",
                        url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=connections_upload",
                        data: JSON.stringify(JSONdata),
                        dataType: "json",
                        success: function (data) {
                            console.log("線段" + data.state + data.message);
                        },
                        error: function () {
                            Swal.fire({
                                title: "API串接錯誤",
                                text: "保存線段失敗 請聯繫作者",
                                icon: "error"
                            });
                        }
                    })

                },

                board_upload() {
                    const vm = this;
                    var alterTime = vm.getCurrentTime();
                    var JSONdata02 = {};
                    // 
                    //傳遞至後端API執行上傳行為
                    JSONdata02 = {
                        userId: vm.userId,
                        boardId: vm.boardId,
                        alterTime: alterTime,
                        boardName: vm.boardName,
                    }

                    console.log(JSONdata02);
                    $.ajax({
                        type: "POST",
                        url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=board_upload",
                        data: JSON.stringify(JSONdata02),
                        dataType: "json",
                        success: function (data) {
                            console.log("畫板名稱" + data.state);
                        },
                        error: function () {
                            Swal.fire({
                                title: "API串接錯誤",
                                text: "保存貼版失敗 請聯繫作者",
                                icon: "error"
                            });
                        }
                    })
                },

                deleteBoard() {
                    const vm = this;
                    Swal.fire({
                        title: "是否刪除此畫板?",
                        showDenyButton: true,
                        icon: "error",
                        // showCancelButton: true,
                        confirmButtonText: "確認",
                        denyButtonText: `取消`
                    }).then((result) => {
                        /* Read more about isConfirmed, isDenied below */
                        if (result.isConfirmed) {
                            var JSONdata = {};

                            JSONdata["userId"] = vm.userId;
                            JSONdata["boardId"] = vm.boardId;
                            // 渲染帳號資料
                            $.ajax({
                                type: "POST",
                                url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=deleteBoard",
                                // url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=advanceDeleteBoard",
                                data: JSON.stringify(JSONdata),
                                dataType: "json",
                                async: false,
                                success: function (data) {
                                    console.log(data.state);
                                    location.href = "StickyCalc_board.html";
                                },
                                error: function () {
                                    alert("發生錯誤"); //練習階段，一切皆用sweetalert
                                }
                            });
                        } else if (result.isDenied) {
                            // Swal.fire("Changes are not saved", "", "info");
                        }
                    });
                },

                checkuid() {
                    //確認UID是否存在
                    const vm = this;
                    if (vm.getCookie("Uid01")) {
                        // 將Uid01傳遞至後端API執行驗證
                        // input {"uid01" : "owne132fd2"}
                        var JSONdata = {};
                        JSONdata["uid01"] = vm.getCookie("Uid01");
                        $.ajax({
                            type: "POST",
                            url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=checkuid",
                            data: JSON.stringify(JSONdata),
                            dataType: "json",
                            success: vm.showdata_checkuid,
                            error: function () {
                                Swal.fire({
                                    title: "API串接錯誤",
                                    text: "member_register_api_v1.php",
                                    icon: "error"
                                });
                            }
                        })
                    } else {

                    }
                },

                showdata_checkuid(data) {
                    const vm = this;
                    console.log(data)
                    if (data.state) {
                        vm.userId = data.data.Username;

                        // 訂閱會員才可使用雲端存儲資料(會員等級30以上)
                        if (data.data.Level >= 30) {
                            // 後端取得
                            vm.get_nodes()
                        }

                        // 從localStorage取得
                        if (vm.nodes == "") {
                            if (localStorage.getItem('nodes')) {
                                try {
                                    vm.nodes = JSON.parse(localStorage.getItem('nodes'));

                                    // 延遲渲染以確保 DOM 準備好
                                    this.$nextTick(() => {
                                        vm.nodes.forEach(chartNode => {
                                            if (chartNode.type === 'chart') {
                                                // this.renderChart(chartNode);
                                                setTimeout(() => this.renderChart(chartNode), 50); // 延遲渲染以確保 DOM 準備好

                                            }
                                        });
                                    });
                                } catch (e) {
                                    localStorage.removeItem('nodes');
                                }
                            }
                            if (localStorage.getItem('connections')) {
                                try {
                                    vm.connections = JSON.parse(localStorage.getItem('connections'));
                                } catch (e) {
                                    localStorage.removeItem('connections');
                                }
                            }
                        }


                        vm.startLocalStorage = true;
                    }
                },

                get_nodes() {
                    const vm = this;
                    var JSONdata = {};
                    console.log("name: " + vm.userId + "board: " + vm.boardId)
                    if (vm.userId && vm.boardId) {
                        JSONdata["userId"] = vm.userId;
                        JSONdata["boardId"] = vm.boardId;
                        $.ajax({
                            type: "POST",
                            url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=get_nodes",
                            data: JSON.stringify(JSONdata),
                            dataType: "json",
                            success: vm.showNodes,
                            error: function () {
                                Swal.fire({
                                    title: "API串接錯誤",
                                    text: "取得便利貼資料失敗 請聯繫作者",
                                    icon: "error"
                                });
                            }
                        })
                    }
                    vm.getConnections();
                },

                showNodes(data) {
                    const vm = this;
                    if (data.data) {
                        vm.nodes = [];
                        for (i = 0; i < data.data.length; i++) {
                            var newData = [];
                            if (data.data[i].Type == 'chart') {
                                newData.push({
                                    "id": data.data[i].Id,
                                    "type": data.data[i].Type,
                                    "chartType": data.data[i].ChartType,
                                    "x": data.data[i].X,
                                    "y": data.data[i].Y,
                                    "chartWidth": 400,
                                    "chartHeight": 240,
                                    "color": data.data[i].Color,
                                    "colorTop": data.data[i].ColorTop,
                                    "connectionsOut": data.data[i].ConnectionsOut,
                                    "connectionsIn": data.data[i].ConnectionsIn,
                                    "connections": data.data[i].Connections,
                                    "userId": data.data[i].UserId,
                                    "boardId": data.data[i].BoardId,
                                    "initialX": 0,
                                    "initialY": 0,
                                    "startX": 0,
                                    "startY": 0,
                                    "editing": false,
                                    "selected": false,
                                })
                            } else {
                                newData.push({
                                    "id": data.data[i].Id,
                                    "label": data.data[i].Label,
                                    "x": data.data[i].X,
                                    "y": data.data[i].Y,
                                    "color": data.data[i].Color,
                                    "colorTop": data.data[i].ColorTop,
                                    "type": data.data[i].Type,
                                    "connectionsOut": data.data[i].ConnectionsOut,
                                    "connectionsIn": data.data[i].ConnectionsIn,
                                    "connections": data.data[i].Connections,
                                    "total": data.data[i].Total,
                                    "count": data.data[i].Count,
                                    "startX": 0,
                                    "startY": 0,
                                    "userId": data.data[i].UserId,
                                    "boardId": data.data[i].BoardId,
                                    "operation": data.data[i].Operation,  // 預設值
                                    "editing": false,
                                    "selected": false,
                                })

                            }
                            vm.nodes.push(newData[0]);
                            // this.computeTotal(vm.nodes[i])

                        }
                    }
                    // 延遲渲染以確保 DOM 準備好
                    this.$nextTick(() => {
                        vm.nodes.forEach(chartNode => {
                            if (chartNode.type === 'chart') {
                                // this.renderChart(chartNode);
                                setTimeout(() => this.renderChart(chartNode), 50); // 延遲渲染以確保 DOM 準備好

                            }
                        });
                    });


                },

                getConnections() {
                    //取得後端的連線資料      
                    const vm = this;
                    var JSONdata = {};

                    if (vm.userId && vm.boardId) {
                        JSONdata["userId"] = vm.userId;
                        JSONdata["boardId"] = vm.boardId;
                        $.ajax({
                            type: "POST",
                            url: "https://api.shawn4x4.com/phpApi/member_control_api_v1.php?action=get_Connections",
                            data: JSON.stringify(JSONdata),
                            dataType: "json",
                            success: vm.showConnections,
                            error: function () {
                                Swal.fire({
                                    title: "API串接錯誤",
                                    text: "取得線條資料失敗 請聯繫作者",
                                    icon: "error"
                                });
                            }
                        })
                    }
                },

                showConnections(data) {
                    const vm = this;
                    if (data.data) {
                        vm.connections = [];
                        for (i = 0; i < data.data.length; i++) {
                            var newData = [];
                            newData.push({
                                "connectionsId": data.data[i].connectionsId,
                                "from": data.data[i].C_from,
                                "to": data.data[i].C_to,
                                "color": data.data[i].Color,
                                "type": data.data[i].Type,
                                "userId": data.data[i].UserId,
                                "boardId": data.data[i].BoardId,
                            })
                            vm.connections.push(newData[0]);
                        }
                    }
                },

                /* ================ 其他 ==================== */

                // 根據 id 取得便利貼資料（用於繪製連線）
                getNodeById(id) {
                    return this.nodes.find(n => n.id === id) || {
                        x: 0,
                        y: 0,
                        label: '',
                        connectionsOut: [],
                        connectionsIn: [],
                        total: 0,
                        count: 0
                    };
                },

                // 計算並返回連線的二次貝茲曲線路徑字串
                getConnectionPath(conn) {
                    const fromNode = this.getNodeById(conn.from);
                    const toNode = this.getNodeById(conn.to);
                    if (!fromNode || !toNode) {
                        console.warn('Nodes not found for connection:', conn);
                        return '';
                    }

                    const fromWidth = fromNode.type === 'chart' ? fromNode.chartWidth : this.noteWidth;
                    const fromHeight = fromNode.type === 'chart' ? fromNode.chartHeight : this.noteHeight;
                    const fromRect = {
                        x: fromNode.x - fromWidth / 2,
                        y: fromNode.y - fromHeight / 2,
                        width: fromWidth,
                        height: fromHeight,
                    };

                    const startEdge = this.getEdgePoint(fromNode, toNode, fromRect);
                    const endEdge = this.getArrowPosition(conn);

                    if (isNaN(startEdge.x) || isNaN(startEdge.y) || isNaN(endEdge.x) || isNaN(endEdge.y)) {
                        console.warn('Invalid edge coordinates:', startEdge, endEdge, 'for connection:', conn);
                        return '';
                    }

                    const dx = endEdge.x - startEdge.x, dy = endEdge.y - startEdge.y;
                    const mx = (startEdge.x + endEdge.x) / 2, my = (startEdge.y + endEdge.y) / 2;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    let offset = 50;
                    if (len === 0) offset = 0;
                    const px = -dy / (len || 1), py = dx / (len || 1);
                    const cx = mx + px * offset, cy = my + py * offset;

                    const path = `M ${startEdge.x} ${startEdge.y} Q ${cx} ${cy} ${endEdge.x} ${endEdge.y}`;
                    return path;
                },

                getCurrentTime() {
                    return new Date().toLocaleString("zh-TW", {
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                        hour12: false,
                    }).replace(/\//g, "-").replace(",", "");
                },

                setCookie(cname, cvalue, exdays) {
                    const d = new Date();
                    d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000));
                    let expires = "expires=" + d.toUTCString();
                    document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
                },

                getCookie(cname) {
                    let name = cname + "=";
                    let ca = document.cookie.split(';');
                    for (let i = 0; i < ca.length; i++) {
                        let c = ca[i];
                        while (c.charAt(0) == ' ') {
                            c = c.substring(1);
                        }
                        if (c.indexOf(name) == 0) {
                            return c.substring(name.length, c.length);
                        }
                    }
                    return "";
                },
            },
            components: {
                'svg-icon': SvgIcon,
                'svg-main': SvgMain,
            },

        });
        app.mount('#app');




    </script>
</body>

</html>